Content-Type: multipart/related; start=<op.mhtml.1512867154221.b48ce2493a3e03d0@192.168.1.95>; boundary=----------X5ScjEJDEcKR21fOfR0crs
Content-Location: file://localhost/D:/SVN/mame-other/mame-feos/debughelp.html
MIME-Version: 1.0

------------X5ScjEJDEcKR21fOfR0crs
Content-Disposition: inline; filename=debughelp.html
Content-Type: text/html; name=debughelp.html
Content-ID: <op.mhtml.1512867154221.b48ce2493a3e03d0@192.168.1.95>
Content-Location: file://localhost/D:/SVN/mame-other/mame-feos/debughelp.html
Content-Transfer-Encoding: Quoted-Printable

<a name=3D"contents">Contents</a><br>
<a href=3D"#"></a><br>
<a href=3D"#general">general</a><br>
<a href=3D"#memory">memory</a><br>
<a href=3D"#execution">execution</a><br>
<a href=3D"#breakpoints">breakpoints</a><br>
<a href=3D"#watchpoints">watchpoints</a><br>
<a href=3D"#registerpoints">registerpoints</a><br>
<a href=3D"#expressions">expressions</a><br>
<a href=3D"#comments">comments</a><br>
<a href=3D"#cheats">cheats</a><br>
<a href=3D"#image">image</a><br>
<a href=3D"#do">do</a><br>
<a href=3D"#symlist">symlist</a><br>
<a href=3D"#softreset">softreset</a><br>
<a href=3D"#hardreset">hardreset</a><br>
<a href=3D"#print">print</a><br>
<a href=3D"#printf">printf</a><br>
<a href=3D"#logerror">logerror</a><br>
<a href=3D"#tracelog">tracelog</a><br>
<a href=3D"#tracesym">tracesym</a><br>
<a href=3D"#trackpc">trackpc</a><br>
<a href=3D"#trackmem">trackmem</a><br>
<a href=3D"#pcatmem">pcatmem</a><br>
<a href=3D"#rewind[rw]">rewind[rw]</a><br>
<a href=3D"#statesave[ss]">statesave[ss]</a><br>
<a href=3D"#stateload[sl]">stateload[sl]</a><br>
<a href=3D"#snap">snap</a><br>
<a href=3D"#source">source</a><br>
<a href=3D"#quit">quit</a><br>
<a href=3D"#dasm">dasm</a><br>
<a href=3D"#find">find</a><br>
<a href=3D"#dump">dump</a><br>
<a href=3D"#save">save</a><br>
<a href=3D"#load">load</a><br>
<a href=3D"#step">step</a><br>
<a href=3D"#over">over</a><br>
<a href=3D"#out">out</a><br>
<a href=3D"#go">go</a><br>
<a href=3D"#gvblank">gvblank</a><br>
<a href=3D"#gint">gint</a><br>
<a href=3D"#gtime">gtime</a><br>
<a href=3D"#next">next</a><br>
<a href=3D"#focus">focus</a><br>
<a href=3D"#ignore">ignore</a><br>
<a href=3D"#observe">observe</a><br>
<a href=3D"#trace">trace</a><br>
<a href=3D"#traceover">traceover</a><br>
<a href=3D"#traceflush">traceflush</a><br>
<a href=3D"#bpset">bpset</a><br>
<a href=3D"#bpclear">bpclear</a><br>
<a href=3D"#bpdisable">bpdisable</a><br>
<a href=3D"#bpenable">bpenable</a><br>
<a href=3D"#bplist">bplist</a><br>
<a href=3D"#wpset">wpset</a><br>
<a href=3D"#wpclear">wpclear</a><br>
<a href=3D"#wpdisable">wpdisable</a><br>
<a href=3D"#wpenable">wpenable</a><br>
<a href=3D"#wplist">wplist</a><br>
<a href=3D"#hotspot">hotspot</a><br>
<a href=3D"#rpset">rpset</a><br>
<a href=3D"#rpclear">rpclear</a><br>
<a href=3D"#rpdisable">rpdisable</a><br>
<a href=3D"#rpenable">rpenable</a><br>
<a href=3D"#rplist">rplist</a><br>
<a href=3D"#map">map</a><br>
<a href=3D"#memdump">memdump</a><br>
<a href=3D"#comlist">comlist</a><br>
<a href=3D"#comadd">comadd</a><br>
<a href=3D"#commit">commit</a><br>
<a href=3D"#comsave">comsave</a><br>
<a href=3D"#comdelete">comdelete</a><br>
<a href=3D"#cheatinit">cheatinit</a><br>
<a href=3D"#cheatrange">cheatrange</a><br>
<a href=3D"#cheatnext">cheatnext</a><br>
<a href=3D"#cheatnextf">cheatnextf</a><br>
<a href=3D"#cheatlist">cheatlist</a><br>
<a href=3D"#cheatundo">cheatundo</a><br>
<a href=3D"#images">images</a><br>
<a href=3D"#mount">mount</a><br>
<a href=3D"#unmount">unmount</a><br>
<a name=3D""><h3></h3></a>
MAME Debugger Help
<pre>  help [&lt;topic>] -- get help on a particular topic</pre>

Topics:
<pre>  General</pre>
<pre>  Memory</pre>
<pre>  Execution</pre>
<pre>  Breakpoints</pre>
<pre>  Watchpoints</pre>
<pre>  Registerpoints</pre>
<pre>  Expressions</pre>
<pre>  Comments</pre>
<pre>  Cheats</pre>
<pre>  Image</pre>
<br><a name=3D"general"><h3>general</h3></a>
General Debugger Help
Type help &lt;command> for further details on each command

<pre>  help [&lt;topic>] -- get help on a particular topic</pre>
<pre>  do &lt;expression> -- evaluates the given expression</pre>
<pre>  symlist [&lt;cpu>] -- lists registered symbols</pre>
<pre>  softreset -- executes a soft reset</pre>
<pre>  hardreset -- executes a hard reset</pre>
<pre>  print &lt;item>[,...] -- prints one or more &lt;item>s to the con=
sole</pre>
<pre>  printf &lt;format>[,&lt;item>[,...]] -- prints one or more &lt;it=
em>s to the console using &lt;format></pre>
<pre>  logerror &lt;format>[,&lt;item>[,...]] -- outputs one or more &lt=
;item>s to the error.log</pre>
<pre>  tracelog &lt;format>[,&lt;item>[,...]] -- outputs one or more &lt=
;item>s to the trace file using &lt;format></pre>
<pre>  tracesym &lt;item>[,...]] -- outputs one or more &lt;item>s to th=
e trace file</pre>
<pre>  history [&lt;cpu>,&lt;length>] -- outputs a brief history of visi=
ted opcodes</pre>
<pre>  trackpc [&lt;bool>,&lt;cpu>,&lt;bool>] -- visually track visited =
opcodes [boolean to turn on and off, for the given cpu, clear]</pre>
<pre>  trackmem [&lt;bool>,&lt;bool>] -- record which PC writes to each =
memory address [boolean to turn on and off, clear]</pre>
<pre>  pcatmemp &lt;address>[,&lt;cpu>] -- query which PC wrote to a giv=
en program memory address for the current CPU</pre>
<pre>  pcatmemd &lt;address>[,&lt;cpu>] -- query which PC wrote to a giv=
en data memory address for the current CPU</pre>
<pre>  pcatmemi &lt;address>[,&lt;cpu>] -- query which PC wrote to a giv=
en I/O memory address for the current CPU</pre>
<pre>                                (Note: you can also query this info=
 by right clicking in a memory window</pre>
<pre>  rewind[rw] -- go back in time by loading the most recent rewind s=
tate  statesave[ss] &lt;filename> -- save a state file for the current d=
river</pre>
<pre>  stateload[sl] &lt;filename> -- load a state file for the current =
driver</pre>
<pre>  snap [&lt;filename>] -- save a screen snapshot.</pre>
<pre>  source &lt;filename> -- reads commands from &lt;filename> and exe=
cutes them one by one</pre>
<pre>  quit -- exits MAME and the debugger</pre>
<br><a name=3D"memory"><h3>memory</h3></a>
Memory Commands
Type help &lt;command> for further details on each command

<pre>  dasm &lt;filename>,&lt;address>,&lt;length>[,&lt;opcodes>[,&lt;cp=
u>]] -- disassemble to the given file</pre>
<pre>  f[ind] &lt;address>,&lt;length>[,&lt;data>[,...]] -- search progr=
am memory for data</pre>
<pre>  f[ind]d &lt;address>,&lt;length>[,&lt;data>[,...]] -- search data=
 memory for data</pre>
<pre>  f[ind]i &lt;address>,&lt;length>[,&lt;data>[,...]] -- search I/O =
memory for data</pre>
<pre>  dump &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&lt;ascii=
>[,&lt;cpu>]]] -- dump program memory as text</pre>
<pre>  dumpd &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&lt;asci=
i>[,&lt;cpu>]]] -- dump data memory as text</pre>
<pre>  dumpi &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&lt;asci=
i>[,&lt;cpu>]]] -- dump I/O memory as text</pre>
<pre>  save &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>] -- save bi=
nary program memory to the given file</pre>
<pre>  saved &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>] -- save b=
inary data memory to the given file</pre>
<pre>  savei &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>] -- save b=
inary I/O memory to the given file</pre>
<pre>  load &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>] -- load bi=
nary program memory from the given file</pre>
<pre>  loadd &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>] -- load b=
inary data memory from the given file</pre>
<pre>  loadi &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>] -- load b=
inary I/O memory from the given file</pre>
<pre>  map &lt;address> -- map logical program address to physical addre=
ss and bank</pre>
<pre>  mapd &lt;address> -- map logical data address to physical address=
 and bank</pre>
<pre>  mapi &lt;address> -- map logical I/O address to physical address =
and bank</pre>
<pre>  memdump [&lt;filename>] -- dump the current memory map to &lt;fil=
ename></pre>
<br><a name=3D"execution"><h3>execution</h3></a>
Execution Commands
Type help &lt;command> for further details on each command

<pre>  s[tep] [&lt;count>=3D1] -- single steps for &lt;count> instructio=
ns (F11)</pre>
<pre>  o[ver] [&lt;count>=3D1] -- single steps over &lt;count> instructi=
ons (F10)</pre>
<pre>  out -- single steps until the current subroutine/exception handle=
r is exited (Shift-F11)</pre>
<pre>  g[o] [&lt;address>] -- resumes execution, sets temp breakpoint at=
 &lt;address> (F5)</pre>
<pre>  gi[nt] [&lt;irqline>] -- resumes execution, setting temp breakpoi=
nt if &lt;irqline> is taken (F7)</pre>
<pre>  gt[ime] &lt;milliseconds> -- resumes execution until the given de=
lay has elapsed</pre>
<pre>  gv[blank] -- resumes execution, setting temp breakpoint on the ne=
xt VBLANK (F8)</pre>
<pre>  n[ext] -- executes until the next CPU switch (F6)</pre>
<pre>  focus &lt;cpu> -- focuses debugger only on &lt;cpu></pre>
<pre>  ignore [&lt;cpu>[,&lt;cpu>[,...]]] -- stops debugging on &lt;cpu>=
</pre>
<pre>  observe [&lt;cpu>[,&lt;cpu>[,...]]] -- resumes debugging on &lt;c=
pu></pre>
<pre>  trace {&lt;filename>|OFF}[,&lt;cpu>[,&lt;detectloops>[,&lt;action=
>]]] -- trace the given CPU to a file (defaults to active CPU)</pre>
<pre>  traceover {&lt;filename>|OFF}[,&lt;cpu>[,&lt;detectloops>[,&lt;ac=
tion>]]] -- trace the given CPU to a file, but skip subroutines (default=
s to active CPU)</pre>
<pre>  traceflush -- flushes all open trace files</pre>
<br><a name=3D"breakpoints"><h3>breakpoints</h3></a>
Breakpoint Commands
Type help &lt;command> for further details on each command

<pre>  bp[set] &lt;address>[,&lt;condition>[,&lt;action>]] -- sets break=
point at &lt;address></pre>
<pre>  bpclear [&lt;bpnum>] -- clears a given breakpoint or all if no &l=
t;bpnum> specified</pre>
<pre>  bpdisable [&lt;bpnum>] -- disables a given breakpoint or all if n=
o &lt;bpnum> specified</pre>
<pre>  bpenable [&lt;bpnum>] -- enables a given breakpoint or all if no =
&lt;bpnum> specified</pre>
<pre>  bplist -- lists all the breakpoints</pre>
<br><a name=3D"watchpoints"><h3>watchpoints</h3></a>
Watchpoint Commands
Type help &lt;command> for further details on each command

<pre>  wp[set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>[,&lt;a=
ction>]] -- sets program space watchpoint</pre>
<pre>  wpd[set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>[,&lt;=
action>]] -- sets data space watchpoint</pre>
<pre>  wpi[set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>[,&lt;=
action>]] -- sets I/O space watchpoint</pre>
<pre>  wpclear [&lt;wpnum>] -- clears a given watchpoint or all if no &l=
t;wpnum> specified</pre>
<pre>  wpdisable [&lt;wpnum>] -- disables a given watchpoint or all if n=
o &lt;wpnum> specified</pre>
<pre>  wpenable [&lt;wpnum>] -- enables a given watchpoint or all if no =
&lt;wpnum> specified</pre>
<pre>  wplist -- lists all the watchpoints</pre>
<pre>  hotspot [&lt;cpu>,[&lt;depth>[,&lt;hits>]]] -- attempt to find ho=
tspots</pre>
<br><a name=3D"registerpoints"><h3>registerpoints</h3></a>
Registerpoint Commands
Type help &lt;command> for further details on each command

<pre>  rp[set] {&lt;condition>}[,&lt;action>] -- sets a registerpoint to=
 trigger on &lt;condition></pre>
<pre>  rpclear [&lt;rpnum>] -- clears a given registerpoint or all if no=
 &lt;rpnum> specified</pre>
<pre>  rpdisable [&lt;rpnum>] -- disabled a given registerpoint or all i=
f no &lt;rpnum> specified</pre>
<pre>  rpenable [&lt;rpnum>]  -- enables a given registerpoint or all if=
 no &lt;rpnum> specified</pre>
<pre>  rplist -- lists all the registerpoints</pre>
<br><a name=3D"expressions"><h3>expressions</h3></a>
Expressions can be used anywhere a numeric parameter is expected. The sy=
ntax for expressions is very close to standard C-style syntax with full =
operator ordering and parentheses. There are a few operators missing (no=
tably the trinary ? : operator), and a few new ones (memory accessors). =
The table below lists all the operators in their order, highest preceden=
ce operators first.

<pre>  ( ) : standard parentheses</pre>
<pre>  ++ -- : postfix increment/decrement</pre>
<pre>  ++ -- ~ ! - + b@ w@ d@ q@ : prefix inc/dec, binary NOT, logical N=
OT, unary +/-, memory access</pre>
<pre>  * / % : multiply, divide, modulus</pre>
<pre>  + - : add, subtract</pre>
<pre>  &lt;&lt; >> : shift left/right</pre>
<pre>  &lt; &lt;=3D > >=3D : less than, less than or equal, greater than=
, greater than or equal</pre>
<pre>  =3D=3D !=3D : equal, not equal</pre>
<pre>  & : binary AND</pre>
<pre>  ^ : binary XOR</pre>
<pre>  | : binary OR</pre>
<pre>  && : logical AND</pre>
<pre>  || : logical OR</pre>
<pre>  =3D *=3D /=3D %=3D +=3D -=3D &lt;&lt;=3D >>=3D &=3D |=3D ^=3D : a=
ssignment</pre>
<pre>  , : separate terms, function parameters</pre>

These are the differences from C behaviors. First, All math is performed=
 on full 64-bit unsigned values, so things like a &lt; 0 won't work as e=
xpected. Second, the logical operators && and || do not have short-circu=
it properties -- both halves are always evaluated. Finally, the new memo=
ry operators work like this: b@&lt;addr> refers to the byte read from &l=
t;addr>. Similarly, w@ refers to a word in memory, d@ refers to a dword =
in memory, and q@ refers to a qword in memory. The memory operators can =
be used as both lvalues and rvalues, so you can write b@100 =3D ff to st=
ore a byte in memory. By default these operators read from the program m=
emory space, but you can override that by prefixing them with a 'd' or a=
n 'i'. So dw@300 refers to data memory word at address 300 and id@400 re=
fers to an I/O memory dword at address 400.
<br><a name=3D"comments"><h3>comments</h3></a>
Code annotation commands
Type help &lt;command> for further details on each command

<pre>  comadd[//] &lt;address>,&lt;comment> -- adds a comment to the dis=
assembled code at given address</pre>
<pre>  comdelete &lt;address> -- removes a comment from the given addres=
s</pre>
<pre>  comsave -- save the current comments to a file</pre>
<pre>  comlist -- print currently available comments from file</pre>
<pre>  commit[/*] &lt;address>,&lt;comment> -- gives a bulk comadd then =
comsave command</pre>

<br><a name=3D"cheats"><h3>cheats</h3></a>
Cheat Commands
Type help &lt;command> for further details on each command

<pre>  cheatinit [&lt;address>,&lt;length>[,&lt;cpu>]] -- initialize the=
 cheat search to the selected memory area</pre>
<pre>  cheatrange &lt;address>,&lt;length> -- add to the cheat search th=
e selected memory area</pre>
<pre>  cheatnext &lt;condition>[,&lt;comparisonvalue>] -- continue cheat=
 search comparing with the last value</pre>
<pre>  cheatnextf &lt;condition>[,&lt;comparisonvalue>] -- continue chea=
t search comparing with the first value</pre>
<pre>  cheatlist [&lt;filename>] -- show the list of cheat search matche=
s or save them to &lt;filename></pre>
<pre>  cheatundo -- undo the last cheat search (state only)</pre>
<br><a name=3D"image"><h3>image</h3></a>
Image Commands
Type help &lt;command> for further details on each command

<pre>  images -- lists all image devices and mounted files</pre>
<pre>  mount &lt;device>,&lt;filename> -- mounts file to named device</p=
re>
<pre>  unmount &lt;device> -- unmounts file from named device</pre>
<br><a name=3D"do"><h3>do</h3></a>
<pre>  do &lt;expression></pre>

The do command simply evaluates the given &lt;expression>. This is typic=
ally used to set or modify variables.

Examples:

do pc =3D 0
<pre>  Sets the register 'pc' to 0.</pre>
<br><a name=3D"symlist"><h3>symlist</h3></a>
<pre>  symlist [&lt;cpu>]</pre>

Lists registered symbols. If &lt;cpu> is not specified, then symbols in =
the global symbol table are displayed; otherwise, the symbols for &lt;cp=
u>'s specific CPU are displayed. Symbols are listed alphabetically. Read=
-only symbols are flagged with an asterisk.

Examples:

symlist
<pre>  Displays the global symbol table.</pre>

symlist 2
<pre>  Displays the symbols specific to CPU #2.</pre>
<br><a name=3D"softreset"><h3>softreset</h3></a>
<pre>  softreset</pre>

Executes a soft reset.

Examples:

softreset
<pre>  Executes a soft reset.</pre>
<br><a name=3D"hardreset"><h3>hardreset</h3></a>
<pre>  hardreset</pre>

Executes a hard reset.

Examples:

hardreset
<pre>  Executes a hard reset.</pre>
<br><a name=3D"print"><h3>print</h3></a>
<pre>  print &lt;item>[,...]</pre>

The print command prints the results of one or more expressions to the d=
ebugger console as hexadecimal values.

Examples:

print pc
<pre>  Prints the value of 'pc' to the console as a hex number.</pre>

print a,b,a+b
<pre>  Prints a, b, and the value of a+b to the console as hex numbers.<=
/pre>
<br><a name=3D"printf"><h3>printf</h3></a>
<pre>  printf &lt;format>[,&lt;item>[,...]]</pre>

The printf command performs a C-style printf to the debugger console. On=
ly a very limited set of formatting options are available:

<pre>  %[0][&lt;n>]d -- prints &lt;item> as a decimal value with optiona=
l digit count and zero-fill</pre>
<pre>  %[0][&lt;n>]x -- prints &lt;item> as a hexadecimal value with opt=
ional digit count and zero-fill</pre>

All remaining formatting options are ignored. Use %% together to output =
a % character. Multiple lines can be printed by embedding a \n in the te=
xt.

Examples:

printf "PC=3D%04X",pc
<pre>  Prints PC=3D&lt;pcval> where &lt;pcval> is displayed in hexadecim=
al with 4 digits with zero-fill.</pre>

printf "A=3D%d, B=3D%d\nC=3D%d",a,b,a+b
<pre>  Prints A=3D&lt;aval>, B=3D&lt;bval> on one line, and C=3D&lt;a+bv=
al> on a second line.</pre>
<br><a name=3D"logerror"><h3>logerror</h3></a>
<pre>  logerror &lt;format>[,&lt;item>[,...]]</pre>

The logerror command performs a C-style printf to the error log. Only a =
very limited set of formatting options are available:

<pre>  %[0][&lt;n>]d -- logs &lt;item> as a decimal value with optional =
digit count and zero-fill</pre>
<pre>  %[0][&lt;n>]x -- logs &lt;item> as a hexadecimal value with optio=
nal digit count and zero-fill</pre>

All remaining formatting options are ignored. Use %% together to output =
a % character. Multiple lines can be printed by embedding a \n in the te=
xt.

Examples:

logerror "PC=3D%04X",pc
<pre>  Logs PC=3D&lt;pcval> where &lt;pcval> is displayed in hexadecimal=
 with 4 digits with zero-fill.</pre>

logerror "A=3D%d, B=3D%d\nC=3D%d",a,b,a+b
<pre>  Logs A=3D&lt;aval>, B=3D&lt;bval> on one line, and C=3D&lt;a+bval=
> on a second line.</pre>
<br><a name=3D"tracelog"><h3>tracelog</h3></a>
<pre>  tracelog &lt;format>[,&lt;item>[,...]]</pre>

The tracelog command performs a C-style printf and routes the output to =
the currently open trace file (see the 'trace' command for details). If =
no file is currently open, tracelog does nothing. Only a very limited se=
t of formatting options are available. See the 'printf' help for details=
.

Examples:

tracelog "PC=3D%04X",pc
<pre>  Outputs PC=3D&lt;pcval> where &lt;pcval> is displayed in hexadeci=
mal with 4 digits with zero-fill.</pre>

printf "A=3D%d, B=3D%d\nC=3D%d",a,b,a+b
<pre>  Outputs A=3D&lt;aval>, B=3D&lt;bval> on one line, and C=3D&lt;a+b=
val> on a second line.</pre>
<br><a name=3D"tracesym"><h3>tracesym</h3></a>
<pre>  tracesym &lt;item>[,...]</pre>

The tracesym command prints the specified symbols and routes the output =
to the currently open trace file (see the 'trace' command for details). =
If no file is currently open, tracesym does nothing. =

Examples:

tracelog pc
<pre>  Outputs PC=3D&lt;pcval> where &lt;pcval> is displayed in the defa=
ult format.</pre>

printf a,b
<pre>  Outputs A=3D&lt;aval>, B=3D&lt;bval> on one line.</pre>
<br><a name=3D"trackpc"><h3>trackpc</h3></a>
<pre>  trackpc [&lt;bool>,&lt;cpu>,&lt;bool>]</pre>

The trackpc command displays which program counters have already been vi=
sited in all disassembler windows. The first boolean argument toggles th=
e process on and off.  The second argument is a cpu selector; if no cpu =
is specified, the current cpu is automatically selected.  The third argu=
ment is a boolean denoting if the existing data should be cleared or not=
.

Examples:

trackpc 1
<pre>  Begin tracking the current cpu's pc.</pre>

trackpc 1, 0, 1
<pre>  Continue tracking pc on cpu 0, but clear existing track info.</pr=
e>
<br><a name=3D"trackmem"><h3>trackmem</h3></a>
<pre>  trackmem [&lt;bool>,&lt;cpu>,&lt;bool>]</pre>

The trackmem command logs the PC at each time a memory address is writte=
n to.  The first boolean argument toggles the process on and off.  The s=
econd argument is a cpu selector; if no cpu is specified, the current cp=
u is automatically selected. The third argument  is a boolean denoting i=
f the existing data should be cleared or not.  Please refer to the pcatm=
em command for information on how to retrieve this data.  Also, right cl=
icking in a memory window will display the logged PC for the given addre=
ss.

Examples:

trackmem
<pre>  Begin tracking the current CPU's pc.</pre>

trackmem 1, 0, 1
<pre>  Continue tracking memory writes on cpu 0, but clear existing trac=
k info.</pre>
<br><a name=3D"pcatmem"><h3>pcatmem</h3></a>
<pre>  pcatmem(p/d/i) &lt;address>[,&lt;cpu>]</pre>

The pcatmem command returns which PC wrote to a given memory address for=
 the current CPU. The first argument is the requested address.  The seco=
nd argument is a cpu selector; if no cpu is specified, the current cpu i=
s automatically selected.  Right clicking in a memory window will also d=
isplay the logged PC for the given address.

Examples:

pcatmem 400000
<pre>  Print which PC wrote this CPU's memory location 0x400000.</pre>
<br><a name=3D"rewind[rw]"><h3>rewind[rw]</h3></a>
<pre>  rewind[rw]</pre>
The rewind command loads the most recent RAM-based state.  Rewind states=
, when enabled, are saved when "step", "over", or "out" command gets exe=
cuted, storing the machine state as of the moment before actually stepin=
g.  Consecutively loading rewind states can work like reverse execution.=
  Depending on which steps forward were taken previously, the bahavior c=
an be similar to GDB's "reverse-stepi" or "reverse-next".  All output fo=
r this command is currently echoed into the running machine window.  Pre=
vious memory and PC tracking statistics are cleared, actual reverse exec=
ution does not occur.
<br><a name=3D"statesave[ss]"><h3>statesave[ss]</h3></a>
<pre>  statesave[ss] &lt;filename></pre>

The statesave command creates a save state at this exact moment in time.=
 The given state file gets written to the standard state directory (sta)=
, and gets .sta to it - no file extension necessary.  All output for thi=
s command is currently echoed into the running machine window.

Examples:

statesave foo
<pre>  Writes file 'foo.sta' in the default state save directory.</pre>
<br><a name=3D"stateload[sl]"><h3>stateload[sl]</h3></a>
<pre>  stateload[sl] &lt;filename></pre>

The stateload command retrieves a save state from disk. The given state =
file gets read from the standard state directory (sta), and gets .sta to=
 it - no file extension necessary.  All output for this command is curre=
ntly echoed into the running machine window.  Previous memory and PC tra=
cking statistics are cleared.

Examples:

stateload foo
<pre>  Reads file 'foo.sta' from the default state save directory.</pre>=

<br><a name=3D"snap"><h3>snap</h3></a>
<pre>  snap [[&lt;filename>], &lt;scrnum>]</pre>

The snap command takes a snapshot of the current video display and saves=
 it to the configured snapshot directory. If &lt;filename> is specified =
explicitly, a single screenshot for &lt;scrnum> is saved under the reque=
sted filename. If &lt;filename> is omitted, all screens are saved using =
the same default rules as the "save snapshot" key in MAME proper.

Examples:

snap
<pre>  Takes a snapshot of the current video screen and saves to the nex=
t non-conflicting filename   in the configured snapshot directory.</pre>=


snap shinobi
<pre>  Takes a snapshot of the current video screen and saves it as 'shi=
nobi.png' in the configured   snapshot directory.</pre>
<br><a name=3D"source"><h3>source</h3></a>
<pre>  source &lt;filename></pre>

The source command reads in a set of debugger commands from a file and e=
xecutes them one by one, similar to a batch file.

Examples:

source break_and_trace.cmd
<pre>  Reads in debugger commands from break_and_trace.cmd and executes =
them.</pre>
<br><a name=3D"quit"><h3>quit</h3></a>
<pre>  quit</pre>

The quit command exits MAME immediately.
<br><a name=3D"dasm"><h3>dasm</h3></a>
<pre>  dasm &lt;filename>,&lt;address>,&lt;length>[,&lt;opcodes>[,&lt;cp=
u>]]</pre>

The dasm command disassembles program memory to the file specified in th=
e &lt;filename> parameter. &lt;address> indicates the address of the sta=
rt of disassembly, and &lt;length> indicates how much memory to disassem=
ble. The range &lt;address> through &lt;address>+&lt;length>-1 inclusive=
 will be output to the file. By default, the raw opcode data is output w=
ith each line. The optional &lt;opcodes> parameter can be used to enable=
 (1) or disable(0) this feature. Finally, you can disassemble code from =
another CPU by specifying the &lt;cpu> parameter.

Examples:

dasm venture.asm,0,10000
<pre>  Disassembles addresses 0-ffff in the current CPU, including raw o=
pcode data, to the file 'venture.asm'.</pre>

dasm harddriv.asm,3000,1000,0,2
<pre>  Disassembles addresses 3000-3fff from CPU #2, with no raw opcode =
data, to the file 'harddriv.asm'.</pre>
<br><a name=3D"find"><h3>find</h3></a>
<pre>  f[ind][{d|i}] &lt;address>,&lt;length>[,&lt;data>[,...]]</pre>

The find/findd/findi commands search through memory for the specified se=
quence of data. 'find' will search program space memory, while 'findd' w=
ill search data space memory and 'findi' will search I/O space memory. &=
lt;address> indicates the address to begin searching, and &lt;length> in=
dicates how much memory to search. &lt;data> can either be a quoted stri=
ng or a numeric value or expression or the wildcard character '?'. Strin=
gs by default imply a byte-sized search; non-string data is searched by =
default in the native word size of the CPU. To override the search size =
for non-strings, you can prefix the value with b. to force byte- sized s=
earch, w. for word-sized search, d. for dword-sized, and q. for qword-si=
zed. Overrides are remembered, so if you want to search for a series of =
words, you need only to prefix the first value with a w. Note also that =
you can intermix sizes in order to perform more complex searches. The en=
tire range &lt;address> through &lt;address>+&lt;length>-1  inclusive wi=
ll be searched for the sequence, and all occurrences will be displayed.

Examples:

find 0,10000,"HIGH SCORE",0
<pre>  Searches the address range 0-ffff in the current CPU for the stri=
ng "HIGH SCORE" followed by a 0 byte.</pre>

findd 3000,1000,w.abcd,4567
<pre>  Searches the data memory address range 3000-3fff for the word-siz=
ed value abcd followed by the word-sized value 4567.</pre>

find 0,8000,"AAR",d.0,"BEN",w.0
<pre>  Searches the address range 0000-7fff for the string "AAR" followe=
d by a dword-sized 0 followed by the string "BEN", followed by a word-si=
zed 0.</pre>
<br><a name=3D"dump"><h3>dump</h3></a>
<pre>  dump[{d|i}] &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&l=
t;ascii>[,&lt;cpu>]]]</pre>

The dump/dumpd/dumpi commands dump memory to the text file specified in =
the &lt;filename> parameter. 'dump' will dump program space memory, whil=
e 'dumpd' will dump data space memory and 'dumpi' will dump I/O space me=
mory. &lt;address> indicates the address of the start of dumping, and &l=
t;length> indicates how much memory to dump. The range &lt;address> thro=
ugh &lt;address>+&lt;length>-1 inclusive will be output to the file. By =
default, the data will be output in byte format, unless the underlying a=
ddress space is word/dword/qword-only. You can override this by specifyi=
ng the &lt;size> parameter, which can be used to group the data in 1, 2,=
 4 or 8-byte chunks. The optional &lt;ascii> parameter can be used to en=
able (1) or disable (0) the output of ASCII characters to the right of e=
ach line; by default, this is enabled. Finally, you can dump memory from=
 another CPU by specifying the &lt;cpu> parameter.

Examples:

dump venture.dmp,0,10000
<pre>  Dumps addresses 0-ffff in the current CPU in 1-byte chunks, inclu=
ding ASCII data, to the file 'venture.dmp'.</pre>

dumpd harddriv.dmp,3000,1000,4,0,3
<pre>  Dumps data memory addresses 3000-3fff from CPU #3 in 4-byte chunk=
s, with no ASCII data, to the file 'harddriv.dmp'.</pre>
<br><a name=3D"save"><h3>save</h3></a>
<pre>  save[{d|i}] &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>]</pr=
e>

The save/saved/savei commands save raw memory to the binary file specifi=
ed in the &lt;filename> parameter. 'save' will save program space memory=
, while 'saved' will save data space memory and 'savei' will save I/O sp=
ace memory. &lt;address> indicates the address of the start of saving, a=
nd &lt;length> indicates how much memory to save. The range &lt;address>=
 through &lt;address>+&lt;length>-1 inclusive will be output to the file=
. You can also save memory from another CPU by specifying the &lt;cpu> p=
arameter.

Examples:

save venture.bin,0,10000
<pre>  Saves addresses 0-ffff in the current CPU to the binary file 'ven=
ture.bin'.</pre>

saved harddriv.bin,3000,1000,3
<pre>  Saves data memory addresses 3000-3fff from CPU #3 to the binary f=
ile 'harddriv.bin'.</pre>
<br><a name=3D"load"><h3>load</h3></a>
<pre>  load[{d|i}] &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>]</pr=
e>

The load/loadd/loadi commands load raw memory from the binary file speci=
fied in the &lt;filename> parameter. 'load' will load program space memo=
ry, while 'loadd' will load data space memory and 'loadi' will load I/O =
space memory. &lt;address> indicates the address of the start of saving,=
 and &lt;length> indicates how much memory to load. The range &lt;addres=
s> through &lt;address>+&lt;length>-1 inclusive will be read in from the=
 file. If you specify &lt;length> =3D 0 or a length greater than the tot=
al length of the file it will load the entire contents of the file and n=
o more. You can also load memory from another CPU by specifying the &lt;=
cpu> parameter.
NOTE: This will only actually write memory that is possible to overwrite=
 in the Memory Window

Examples:

load venture.bin,0,10000
<pre>  Loads addresses 0-ffff in the current CPU from the binary file 'v=
enture.bin'.</pre>

loadd harddriv.bin,3000,1000,3
<pre>  Loads data memory addresses 3000-3fff from CPU #3 from the binary=
 file 'harddriv.bin'.</pre>
<br><a name=3D"step"><h3>step</h3></a>
<pre>  s[tep] [&lt;count>=3D1]</pre>

The step command single steps one or more instructions in the currently =
executing CPU. By default, step executes one instruction each time it is=
 issued. You can also tell step to step multiple instructions by includi=
ng the optional &lt;count> parameter.

Examples:

s
<pre>  Steps forward one instruction on the current CPU.</pre>

step 4
<pre>  Steps forward four instructions on the current CPU.</pre>
<br><a name=3D"over"><h3>over</h3></a>
<pre>  o[ver] [&lt;count>=3D1]</pre>

The over command single steps "over" one or more instructions in the cur=
rently executing CPU, stepping over subroutine calls and exception handl=
er traps and counting them as a single instruction. Note that when stepp=
ing over a subroutine call, code may execute on other CPUs before the su=
broutine call completes. By default, over executes one instruction each =
time it is issued. You can also tell step to step multiple instructions =
by including the optional &lt;count> parameter.

Note that the step over functionality may not be implemented on all CPU =
types. If it is not implemented, then 'over' will behave exactly like 's=
tep'.

Examples:

o
<pre>  Steps forward over one instruction on the current CPU.</pre>

over 4
<pre>  Steps forward over four instructions on the current CPU.</pre>
<br><a name=3D"out"><h3>out</h3></a>
<pre>  out</pre>

The out command single steps until it encounters a return from subroutin=
e or return from exception instruction. Note that because it detects ret=
urn from exception conditions, if you attempt to step out of a subroutin=
e and an interrupt/exception occurs before you hit the end, then you may=
 stop prematurely at the end of the exception handler.

Note that the step out functionality may not be implemented on all CPU t=
ypes. If it is not implemented, then 'out' will behave exactly like 'ste=
p'.

Examples:

out
<pre>  Steps until the current subroutine or exception handler returns.<=
/pre>
<br><a name=3D"go"><h3>go</h3></a>
<pre>  g[o] [&lt;address>]</pre>

The go command resumes execution of the current code. Control will not b=
e returned to the debugger until a breakpoint or watchpoint is hit, or u=
ntil you manually break in using the assigned key. The go command takes =
an optional &lt;address> parameter which is a temporary unconditional br=
eakpoint that is set before executing, and automatically removed when hi=
t. =

Examples:

g
<pre>  Resume execution until the next break/watchpoint or until a manua=
l break.</pre>

g 1234
<pre>  Resume execution, stopping at address 1234 unless something else =
stops us first.</pre>
<br><a name=3D"gvblank"><h3>gvblank</h3></a>
<pre>  gv[blank]</pre>

The gvblank command resumes execution of the current code. Control will =
not be returned to the debugger until a breakpoint or watchpoint is hit,=
 or until the next VBLANK occurs in the emulator.

Examples:

gv
<pre>  Resume execution until the next break/watchpoint or until the nex=
t VBLANK.</pre>
<br><a name=3D"gint"><h3>gint</h3></a>
<pre>  gi[nt] [&lt;irqline>]</pre>

The gint command resumes execution of the current code. Control will not=
 be returned to the debugger until a breakpoint or watchpoint is hit, or=
 until an IRQ is asserted and acknowledged on the current CPU. You can s=
pecify &lt;irqline> if you wish to stop execution only on a particular I=
RQ line being asserted and acknowledged. If &lt;irqline> is omitted, the=
n any IRQ line will stop execution.

Examples:

gi
<pre>  Resume execution until the next break/watchpoint or until any IRQ=
 is asserted and acknowledged on the current CPU.</pre>

gint 4
<pre>  Resume execution until the next break/watchpoint or until IRQ lin=
e 4 is asserted and acknowledged on the current CPU.</pre>
<br><a name=3D"gtime"><h3>gtime</h3></a>
<pre>  gt[ime] &lt;milliseconds></pre>

The gtime command resumes execution of the current code. Control will no=
t be returned to the debugger until a specified delay has elapsed. The d=
elay is in milliseconds.

Example:

gtime #10000
<pre>  Resume execution for ten seconds</pre>
<br><a name=3D"next"><h3>next</h3></a>
<pre>  n[ext]</pre>

The next command resumes execution and continues executing until the nex=
t time a different CPU is scheduled. Note that if you have used 'ignore'=
 to ignore certain CPUs, you will not stop until a non-'ignore'd CPU is =
scheduled.
<br><a name=3D"focus"><h3>focus</h3></a>
<pre>  focus &lt;cpu></pre>

Sets the debugger focus exclusively to the given &lt;cpu>. This is equiv=
alent to specifying 'ignore' on all other CPUs.

Examples:

focus 1
<pre>  Focus exclusively CPU #1 while ignoring all other CPUs when using=
 the debugger.</pre>
<br><a name=3D"ignore"><h3>ignore</h3></a>
<pre>  ignore [&lt;cpu>[,&lt;cpu>[,...]]]</pre>

Ignores the specified &lt;cpu> in the debugger. This means that you won'=
t ever see execution on that CPU, nor will you be able to set breakpoint=
s on that CPU. To undo this change use the 'observe' command. You can sp=
ecify multiple &lt;cpu>s in a single command. Note also that you are not=
 permitted to ignore all CPUs; at least one must be active at all times.=


Examples:

ignore 1
<pre>  Ignore CPU #1 when using the debugger.</pre>

ignore 2,3,4
<pre>  Ignore CPU #2, #3 and #4 when using the debugger.</pre>

ignore
<pre>  List the CPUs that are currently ignored.</pre>
<br><a name=3D"observe"><h3>observe</h3></a>
<pre>  observe [&lt;cpu>[,&lt;cpu>[,...]]]</pre>

Re-enables interaction with the specified &lt;cpu> in the debugger. This=
 command undoes the effects of the 'ignore' command. You can specify mul=
tiple &lt;cpu>s in a single command.

Examples:

observe 1
<pre>  Stop ignoring CPU #1 when using the debugger.</pre>

observe 2,3,4
<pre>  Stop ignoring CPU #2, #3 and #4 when using the debugger.</pre>

observe
<pre>  List the CPUs that are currently observed.</pre>
<br><a name=3D"trace"><h3>trace</h3></a>
<pre>  trace {&lt;filename>|OFF}[,&lt;cpu>[,[noloop|logerror][,&lt;actio=
n>]]]</pre>

Starts or stops tracing of the execution of the specified &lt;cpu>. If &=
lt;cpu> is omitted, the currently active CPU is specified. When enabling=
 tracing, specify the filename in the &lt;filename> parameter. To disabl=
e tracing, substitute the keyword 'off' for &lt;filename>. &lt;detectloo=
ps> should be either true or false. If 'noloop' is omitted, the trace wi=
ll have loops detected and condensed to a single line. If 'noloop' is sp=
ecified, the trace will contain every opcode as it is executed. If 'loge=
rror' is specified, logerror output will augment the trace.  If you wish=
 to log additional information on each trace, you can append an &lt;acti=
on> parameter which is a command that is executed before each trace is l=
ogged. Generally, this is used to include a 'tracelog' command. Note tha=
t you may need to embed the action within braces { } in order to prevent=
 commas and semicolons from being interpreted as applying to the trace c=
ommand itself.

Examples:

trace joust.tr
<pre>  Begin tracing the currently active CPU, logging output to joust.t=
r.</pre>

trace dribling.tr,0
<pre>  Begin tracing the execution of CPU #0, logging output to dribling=
.tr.</pre>

trace starswep.tr,0,noloop
<pre>  Begin tracing the execution of CPU #0, logging output to starswep=
.tr, with loop detection disabled.</pre>

trace starswep.tr,0,logerror
<pre>  Begin tracing the execution of CPU #0, logging output (along with=
 logerror output) to starswep.tr.</pre>

trace starswep.tr,0,logerror|noloop
<pre>  Begin tracing the execution of CPU #0, logging output (along with=
 logerror output) to starswep.tr, with loop detection disabled.</pre>

trace >>pigskin.tr
<pre>  Begin tracing the currently active CPU, appending log output to p=
igskin.tr.</pre>

trace off,0
<pre>  Turn off tracing on CPU #0.</pre>

trace asteroid.tr,0,,{tracelog "A=3D%02X ",a}
<pre>  Begin tracing the execution of CPU #0, logging output to asteroid=
.tr. Before each line, output A=3D&lt;aval> to the tracelog.</pre>
<br><a name=3D"traceover"><h3>traceover</h3></a>
<pre>  traceover {&lt;filename>|OFF}[,&lt;cpu>[,&lt;detectloops>[,&lt;ac=
tion>]]]</pre>

Starts or stops tracing of the execution of the specified &lt;cpu>. When=
 tracing reaches a subroutine or call, tracing will skip over the subrou=
tine. The same algorithm is used as is used in the step over command. Th=
is means that traceover will not work properly when calls are recusive o=
r the return address is not immediately following the call instruction. =
If &lt;detectloops> should be either true or false. If &lt;detectloops> =
is true or omitted, the trace will have loops detected and condensed to =
a single line. If it is false, the trace will contain every opcode as it=
 is executed. If &lt;cpu> is omitted, the currently active CPU is specif=
ied. When enabling tracing, specify the filename in the &lt;filename> pa=
rameter. To disable tracing, substitute the keyword 'off' for &lt;filena=
me>. If you wish to log additional information on each trace, you can ap=
pend an &lt;action> parameter which is a command that is executed before=
 each trace is logged. Generally, this is used to include a 'tracelog' c=
ommand. Note that you may need to embed the action within braces { } in =
order to prevent commas and semicolons from being interpreted as applyin=
g to the trace command itself.

Examples:

traceover joust.tr
<pre>  Begin tracing the currently active CPU, logging output to joust.t=
r.</pre>

traceover dribling.tr,0
<pre>  Begin tracing the execution of CPU #0, logging output to dribling=
.tr.</pre>

traceover starswep.tr,0,false
<pre>  Begin tracing the execution of CPU #0, logging output to starswep=
.tr, with loop detection disabled.</pre>

traceover off,0
<pre>  Turn off tracing on CPU #0.</pre>

traceover asteroid.tr,0,true,{tracelog "A=3D%02X ",a}
<pre>  Begin tracing the execution of CPU #0, logging output to asteroid=
.tr. Before each line, output A=3D&lt;aval> to the tracelog.</pre>
<br><a name=3D"traceflush"><h3>traceflush</h3></a>
<pre>  traceflush</pre>

Flushes all open trace files.
<br><a name=3D"bpset"><h3>bpset</h3></a>
<pre>  bp[set] &lt;address>[,&lt;condition>[,&lt;action>]]</pre>

Sets a new execution breakpoint at the specified &lt;address>. The optio=
nal &lt;condition> parameter lets you specify an expression that will be=
 evaluated each time the breakpoint is hit. If the result of the express=
ion is true (non-zero), the breakpoint will actually halt execution; oth=
erwise, execution will continue with no notification. The optional &lt;a=
ction> parameter provides a command that is executed whenever the breakp=
oint is hit and the &lt;condition> is true. Note that you may need to em=
bed the action within braces { } in order to prevent commas and semicolo=
ns from being interpreted as applying to the bpset command itself. Each =
breakpoint that is set is assigned an index which can be used in other b=
reakpoint commands to reference this breakpoint.

Examples:

bp 1234
<pre>  Set a breakpoint that will halt execution whenever the PC is equa=
l to 1234.</pre>

bp 23456,a0 =3D=3D 0 && a1 =3D=3D 0
<pre>  Set a breakpoint that will halt execution whenever the PC is equa=
l to 23456 AND the expression (a0 =3D=3D 0 && a1 =3D=3D 0) is true.</pre=
>

bp 3456,1,{printf "A0=3D%08X\n",a0; g}
<pre>  Set a breakpoint that will halt execution whenever the PC is equa=
l to 3456. When this happens, print A0=3D&lt;a0val> and continue executi=
ng.</pre>

bp 45678,a0=3D=3D100,{a0 =3D ff; g}
<pre>  Set a breakpoint that will halt execution whenever the PC is equa=
l to 45678 AND the expression (a0 =3D=3D 100) is true. When that happens=
, set a0 to ff and resume execution.</pre>

temp0 =3D 0; bp 567890,++temp0 >=3D 10
<pre>  Set a breakpoint that will halt execution whenever the PC is equa=
l to 567890 AND the expression (++temp0 >=3D 10) is true. This effective=
ly breaks only after the breakpoint has been hit 16 times.</pre>
<br><a name=3D"bpclear"><h3>bpclear</h3></a>
<pre>  bpclear [&lt;bpnum>]</pre>

The bpclear command clears a breakpoint. If &lt;bpnum> is specified, onl=
y the requested breakpoint is cleared, otherwise all breakpoints are cle=
ared.

Examples:

bpclear 3
<pre>  Clear breakpoint index 3.</pre>

bpclear
<pre>  Clear all breakpoints.</pre>
<br><a name=3D"bpdisable"><h3>bpdisable</h3></a>
<pre>  bpdisable [&lt;bpnum>]</pre>

The bpdisable command disables a breakpoint. If &lt;bpnum> is specified,=
 only the requested breakpoint is disabled, otherwise all breakpoints ar=
e disabled. Note that disabling a breakpoint does not delete it, it just=
 temporarily marks the breakpoint as inactive.

Examples:

bpdisable 3
<pre>  Disable breakpoint index 3.</pre>

bpdisable
<pre>  Disable all breakpoints.</pre>
<br><a name=3D"bpenable"><h3>bpenable</h3></a>
<pre>  bpenable [&lt;bpnum>]</pre>

The bpenable command enables a breakpoint. If &lt;bpnum> is specified, o=
nly the requested breakpoint is enabled, otherwise all breakpoints are e=
nabled.

Examples:

bpenable 3
<pre>  Enable breakpoint index 3.</pre>

bpenable
<pre>  Enable all breakpoints.</pre>
<br><a name=3D"bplist"><h3>bplist</h3></a>
<pre>  bplist</pre>

The bplist command lists all the current breakpoints, along with their i=
ndex and any conditions or actions attached to them.
<br><a name=3D"wpset"><h3>wpset</h3></a>
<pre>  wp[{d|i}][set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>=
[,&lt;action>]]</pre>

Sets a new watchpoint starting at the specified &lt;address> and extendi=
ng for &lt;length>. The inclusive range of the watchpoint is &lt;address=
> through &lt;address> + &lt;length> - 1. The 'wpset' command sets a wat=
chpoint on program memory; the 'wpdset' command sets a watchpoint on dat=
a memory; and the 'wpiset' sets a watchpoint on I/O memory. The &lt;type=
> parameter specifies which sort of accesses to trap on. It can be one o=
f three values: 'r' for a read watchpoint 'w' for a write watchpoint, an=
d 'rw' for a read/write watchpoint.

The optional &lt;condition> parameter lets you specify an expression tha=
t will be evaluated each time the watchpoint is hit. If the result of th=
e expression is true (non-zero), the watchpoint will actually halt execu=
tion; otherwise, execution will continue with no notification. The optio=
nal &lt;action> parameter provides a command that is executed whenever t=
he watchpoint is hit and the &lt;condition> is true. Note that you may n=
eed to embed the action within braces { } in order to prevent commas and=
 semicolons from being interpreted as applying to the wpset command itse=
lf. Each watchpoint that is set is assigned an index which can be used i=
n other watchpoint commands to reference this watchpoint.

In order to help &lt;condition> expressions, two variables are available=
. For all watchpoints, the variable 'wpaddr' is set to the address that =
actually triggered the watchpoint. For write watchpoints, the variable '=
wpdata' is set to the data that is being written.

Examples:

wp 1234,6,rw
<pre>  Set a watchpoint that will halt execution whenever a read or writ=
e occurs in the address range 1234-1239 inclusive.</pre>

wp 23456,a,w,wpdata =3D=3D 1
<pre>  Set a watchpoint that will halt execution whenever a write occurs=
 in the address range 23456-2345f AND the data written is equal to 1.</p=
re>

wp 3456,20,r,1,{printf "Read @ %08X\n",wpaddr; g}
<pre>  Set a watchpoint that will halt execution whenever a read occurs =
in the address range 3456-3475. When this happens, print Read @ &lt;wpad=
dr> and continue executing.</pre>

temp0 =3D 0; wp 45678,1,w,wpdata=3D=3Df0,{temp0++; g}
<pre>  Set a watchpoint that will halt execution whenever a write occurs=
 to the address 45678 AND the value being written is equal to f0. When t=
hat happens, increment the variable temp0 and resume execution.</pre>
<br><a name=3D"wpclear"><h3>wpclear</h3></a>
<pre>  wpclear [&lt;wpnum>]</pre>

The wpclear command clears a watchpoint. If &lt;wpnum> is specified, onl=
y the requested watchpoint is cleared, otherwise all watchpoints are cle=
ared.

Examples:

wpclear 3
<pre>  Clear watchpoint index 3.</pre>

wpclear
<pre>  Clear all watchpoints.</pre>
<br><a name=3D"wpdisable"><h3>wpdisable</h3></a>
<pre>  wpdisable [&lt;wpnum>]</pre>

The wpdisable command disables a watchpoint. If &lt;wpnum> is specified,=
 only the requested watchpoint is disabled, otherwise all watchpoints ar=
e disabled. Note that disabling a watchpoint does not delete it, it just=
 temporarily marks the watchpoint as inactive.

Examples:

wpdisable 3
<pre>  Disable watchpoint index 3.</pre>

wpdisable
<pre>  Disable all watchpoints.</pre>
<br><a name=3D"wpenable"><h3>wpenable</h3></a>
<pre>  wpenable [&lt;wpnum>]</pre>

The wpenable command enables a watchpoint. If &lt;wpnum> is specified, o=
nly the requested watchpoint is enabled, otherwise all watchpoints are e=
nabled.

Examples:

wpenable 3
<pre>  Enable watchpoint index 3.</pre>

wpenable
<pre>  Enable all watchpoints.</pre>
<br><a name=3D"wplist"><h3>wplist</h3></a>
<pre>  wplist</pre>

The wplist command lists all the current watchpoints, along with their i=
ndex and any conditions or actions attached to them.
<br><a name=3D"hotspot"><h3>hotspot</h3></a>
<pre>  hotspot [&lt;cpu>,[&lt;depth>[,&lt;hits>]]]</pre>

The hotspot command attempts to help locate hotspots in the code where s=
peedup opportunities might be present. &lt;cpu>, which defaults to the c=
urrently active CPU, specified which processor's memory to track. &lt;de=
pth>, which defaults to 64, controls the depth of the search buffer. The=
 search buffer tracks the last &lt;depth> memory reads from unique PCs. =
The &lt;hits> parameter, which defaults to 250, specifies the minimum nu=
mber of hits to report.

The basic theory of operation is like this: each memory read is trapped =
by the debugger and logged in the search buffer according to the address=
 which was read and the PC that executed the opcode. If the search buffe=
r already contains a matching entry, that entry's count is incremented a=
nd the entry is moved to the top of the list. If the search buffer does =
not contain a matching entry, the entry from the bottom of the list is r=
emoved, and a new entry is created at the top with an initial count of 1=
. Entries which fall off the bottom are examined and if their count is l=
arger than &lt;hits>, they are reported to the debugger console.

Examples:

hotspot 0,10
<pre>  Looks for hotspots on CPU 0 using a search buffer of 16 entries, =
reporting any entries which end up with 250 or more hits.</pre>

hotspot 1,40,#1000
<pre>  Looks for hotspots on CPU 1 using a search buffer of 64 entries, =
reporting any entries which end up with 1000 or more hits.</pre>
<br><a name=3D"rpset"><h3>rpset</h3></a>
<pre>  rp[set] {&lt;condition>}[,&lt;action>]]</pre>

Sets a new registerpoint which will be triggered when &lt;condition> is =
met. The condition must be specified between curly braces to prevent the=
 condition from being evaluated as an assignment.

The optional &lt;action> parameter provides a command that is executed w=
henever the registerpoint is hit. Note that you may need to embed the ac=
tion within braces { } in order to prevent commas and semicolons from be=
ing interpreted as applying to the rpset command itself. Each registerpo=
int that is set is assigned an index which can be used in other register=
point commands to reference this registerpoint.

Examples:

rp {PC=3D=3D0150}
<pre>  Set a registerpoint that will halt execution whenever the PC regi=
ster equals 0x150.</pre>

temp0=3D0; rp {PC=3D=3D0150},{temp0++; g}
<pre>  Set a registerpoint that will increment the variable temp0 whenev=
er the PC register equals 0x0150.</pre>

rp {temp0=3D=3D5}
<pre>  Set a registerpoint that will halt execution whenever the temp0 v=
ariable equals 5.</pre>
<br><a name=3D"rpclear"><h3>rpclear</h3></a>
<pre>  rpclear [&lt;rpnum>]</pre>

The rpclear command clears a registerpoint. If &lt;rpnum> is specified, =
only the requested registerpoint is cleared, otherwise all registerpoint=
s are cleared.

Examples:

rpclear 3
<pre>  Clear registerpoint index 3.</pre>

rpclear
<pre>  Clear all registerpoints.</pre>
<br><a name=3D"rpdisable"><h3>rpdisable</h3></a>
<pre>  rpdisable [&lt;rpnum>]</pre>

The rpdisable command disables a registerpoint. If &lt;rpnum> is specifi=
ed, only the requested registerpoint is disabled, otherwise all register=
points are disabled. Note that disabling a registerpoint does not delete=
 it, it just temporarily marks the registerpoint as inactive.

Examples:

rpdisable 3
<pre>  Disable registerpoint index 3.</pre>

rpdisable
<pre>  Disable all registerpoints.</pre>
<br><a name=3D"rpenable"><h3>rpenable</h3></a>
<pre>  rpenable [&lt;rpnum>]</pre>

The rpenable command enables a registerpoint. If &lt;rpnum> is specified=
, only the requested registerpoint is enabled, otherwise all registerpoi=
nts are enabled.

Examples:

rpenable 3
<pre>  Enable registerpoint index 3.</pre>

rpenable
<pre>  Enable all registerpoints.</pre>
<br><a name=3D"rplist"><h3>rplist</h3></a>
<pre>  rplist</pre>

The rplist command lists all the current registerpoints, along with thei=
r index and any actions attached to them.
<br><a name=3D"map"><h3>map</h3></a>
<pre>  map[{d|i}] &lt;address></pre>

The map/mapd/mapi commands map a logical address in memory to the correc=
t physical address, as well as specifying the bank. 'map' will map progr=
am space memory, while 'mapd' will map data space memory and 'mapi' will=
 map I/O space memory.

Example:

map 152d0
<pre>  Gives physical address and bank for logical address 152d0 in prog=
ram memory</pre>
<br><a name=3D"memdump"><h3>memdump</h3></a>
<pre>  memdump [&lt;filename>]</pre>

Dumps the current memory map to &lt;filename>. If &lt;filename> is omitt=
ed, then dumps to memdump.log
Examples:

memdump mylog.log
<pre>  Dumps memory to mylog.log.</pre>

memdump
<pre>  Dumps memory to memdump.log.</pre>
<br><a name=3D"comlist"><h3>comlist</h3></a>
<pre>  comlist</pre>

Prints the currently available comment file in human readable form in de=
bugger output window.
Examples:

comlist
<pre>  Shows currently available comments.</pre>
<br><a name=3D"comadd"><h3>comadd</h3></a>
<pre>  comadd[//] &lt;address>,&lt;comment></pre>

Adds a string &lt;comment> to the disassembled code at &lt;address>. The=
 shortcut for this command is simply '//'

Examples:

comadd 0, hello world.
<pre>  Adds the comment 'hello world.' to the code at address 0x0</pre>

// 10, undocumented opcode!
<pre>  Adds the comment 'undocumented opcode!' to the code at address 0x=
10</pre>

<br><a name=3D"commit"><h3>commit</h3></a>
<pre>  commit[/*] &lt;address>,&lt;comment></pre>

Adds a string &lt;comment> to the disassembled code at &lt;address> then=
 saves to file. Basically same as comadd + comsave via a single line.
The shortcut for this command is simply '/*'

Examples:

commit 0, hello world.
<pre>  Adds the comment 'hello world.' to the code at address 0x0</pre>

/* 10, undocumented opcode!
<pre>  Adds the comment 'undocumented opcode!' to the code at address 0x=
10</pre>

<br><a name=3D"comsave"><h3>comsave</h3></a>
<pre>  comsave</pre>

Saves the working comments to the driver's XML comment file.

Examples:

comsave
<pre>  Saves the comments to the driver's comment file</pre>

<br><a name=3D"comdelete"><h3>comdelete</h3></a>
<pre>  comdelete</pre>

Deletes the comment at the specified memory offset. The comment which is=
 deleted is in the currently active memory bank.

Examples:

comdelete 10
<pre>  Deletes the comment at code address 0x10 (using the current memor=
y bank settings)</pre>

<br><a name=3D"cheatinit"><h3>cheatinit</h3></a>
<pre>  cheatinit [&lt;sign>&lt;width>&lt;swap>,[&lt;address>,&lt;length>=
[,&lt;cpu>]]]</pre>

The cheatinit command initializes the cheat search to the selected memor=
y area.
If no parameter is specified the cheat search is initialized to all chan=
geable memory of the main cpu.
&lt;sign> can be s(signed) or u(unsigned)
&lt;width> can be b(8 bit), w(16 bit), d(32 bit) or q(64 bit)
&lt;swap> append s for swapped search

Examples:

cheatinit ub,0x1000,0x10
<pre>  Initialize the cheat search from 0x1000 to 0x1010 of the first CP=
U.</pre>

cheatinit sw,0x2000,0x1000,1
<pre>  Initialize the cheat search with width of 2 byte in signed mode f=
rom 0x2000 to 0x3000 of the second CPU.</pre>

cheatinit uds,0x0000,0x1000
<pre>  Initialize the cheat search with width of 4 byte swapped from 0x0=
000 to 0x1000.</pre>
<br><a name=3D"cheatrange"><h3>cheatrange</h3></a>
<pre>  cheatrange &lt;address>,&lt;length></pre>

The cheatrange command adds the selected memory area to the cheat search=
.
Before using cheatrange it is necessary to initialize the cheat search w=
ith cheatinit.

Examples:

cheatrange 0x1000,0x10
<pre>  Add the bytes from 0x1000 to 0x1010 to the cheat search.</pre>
<br><a name=3D"cheatnext"><h3>cheatnext</h3></a>
<pre>  cheatnext &lt;condition>[,&lt;comparisonvalue>]</pre>

The cheatnext command will make comparisons with the last search matches=
.
Possible &lt;condition>:
<pre>  all</pre>
<pre>   no &lt;comparisonvalue> needed.</pre>
<pre>   use to update the last value without changing the current matche=
s.</pre>
<pre>  equal [eq]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that are equal=
 to the last search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are equal to=
 the &lt;comparisonvalue>.</pre>
<pre>  notequal [ne]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that are not e=
qual to the last search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are not equa=
l to the &lt;comparisonvalue>.</pre>
<pre>  decrease [de, +]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that have decr=
eased since the last search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that have decreas=
ed by the &lt;comparisonvalue> since the last search.</pre>
<pre>  increase [in, -]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that have incr=
eased since the last search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that have increas=
ed by the &lt;comparisonvalue> since the last search.</pre>
<pre>  decreaseorequal [deeq]</pre>
<pre>   no &lt;comparisonvalue> needed.</pre>
<pre>   search for all bytes that have decreased or have same value sinc=
e the last search.</pre>
<pre>  increaseorequal [ineq]</pre>
<pre>   no &lt;comparisonvalue> needed.</pre>
<pre>   search for all bytes that have decreased or have same value sinc=
e the last search.</pre>
<pre>  smallerof [lt]</pre>
<pre>   without &lt;comparisonvalue> this condition is invalid</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are smaller =
than the &lt;comparisonvalue>.</pre>
<pre>  greaterof [gt]</pre>
<pre>   without &lt;comparisonvalue> this condition is invalid</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are larger t=
han the &lt;comparisonvalue>.</pre>
<pre>  changedby [ch, ~]</pre>
<pre>   without &lt;comparisonvalue> this condition is invalid</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that have changed=
 by the &lt;comparisonvalue> since the last search.</pre>

Examples:

cheatnext increase
<pre>  search for all bytes that have increased since the last search.</=
pre>

cheatnext decrease, 1
<pre>  search for all bytes that have decreased by 1 since the last sear=
ch.</pre>
<br><a name=3D"cheatnextf"><h3>cheatnextf</h3></a>
<pre>  cheatnextf &lt;condition>[,&lt;comparisonvalue>]</pre>

The cheatnextf command will make comparisons with the initial search.
Possible &lt;condition>:
<pre>  all</pre>
<pre>   no &lt;comparisonvalue> needed.</pre>
<pre>   use to update the last value without changing the current matche=
s.</pre>
<pre>  equal [eq]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that are equal=
 to the initial search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are equal to=
 the &lt;comparisonvalue>.</pre>
<pre>  notequal [ne]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that are not e=
qual to the initial search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are not equa=
l to the &lt;comparisonvalue>.</pre>
<pre>  decrease [de, +]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that have decr=
eased since the initial search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that have decreas=
ed by the &lt;comparisonvalue> since the initial search.</pre>
<pre>  increase [in, -]</pre>
<pre>   without &lt;comparisonvalue> search for all bytes that have incr=
eased since the initial search.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that have increas=
ed by the &lt;comparisonvalue> since the initial search.</pre>
<pre>  decreaseorequal [deeq]</pre>
<pre>   no &lt;comparisonvalue> needed.</pre>
<pre>   search for all bytes that have decreased or have same value sinc=
e the initial search.</pre>
<pre>  increaseorequal [ineq]</pre>
<pre>   no &lt;comparisonvalue> needed.</pre>
<pre>   search for all bytes that have decreased or have same value sinc=
e the initial search.</pre>
<pre>  smallerof [lt]</pre>
<pre>   without &lt;comparisonvalue> this condition is invalid.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are smaller =
than the &lt;comparisonvalue>.</pre>
<pre>  greaterof [gt]</pre>
<pre>   without &lt;comparisonvalue> this condition is invalid.</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that are larger t=
han the &lt;comparisonvalue>.</pre>
<pre>  changedby [ch, ~]</pre>
<pre>   without &lt;comparisonvalue> this condition is invalid</pre>
<pre>   with &lt;comparisonvalue> search for all bytes that have changed=
 by the &lt;comparisonvalue> since the initial search.</pre>

Examples:

cheatnextf increase
<pre>  search for all bytes that have increased since the initial search=
.</pre>

cheatnextf decrease, 1
<pre>  search for all bytes that have decreased by 1 since the initial s=
earch.</pre>
<br><a name=3D"cheatlist"><h3>cheatlist</h3></a>
<pre>  cheatlist [&lt;filename>]</pre>

Without &lt;filename> show the list of matches in the debug console.
With &lt;filename> save the list of matches in basic xml format to &lt;f=
ilename>.

Examples:

cheatlist
<pre>  Show the current matches in the debug console.</pre>
cheatlist cheat.txt
<pre>  Save the current matches to cheat.txt.</pre>
<br><a name=3D"cheatundo"><h3>cheatundo</h3></a>
<pre>  cheatundo</pre>

Undo the results of the last search.
The undo command has no effect on the last value.

Examples:

cheatundo
<pre>  Undo the last search (state only).</pre>
<br><a name=3D"images"><h3>images</h3></a>
<pre>  images</pre>

Used to display list of available image devices.

Examples:

images
<pre>  Show list of devices and mounted files for current driver.</pre>
<br><a name=3D"mount"><h3>mount</h3></a>
<pre>  mount &lt;device>,&lt;filename></pre>

Mount &lt;filename> to image &lt;device>.
&lt;filename> can be softlist item or full path to file.

Examples:

mount cart,aladdin
<pre>  Mounts softlist item alladin on cart device.</pre>
<br><a name=3D"unmount"><h3>unmount</h3></a>
<pre>  unmount &lt;device></pre>

Unmounts file from image &lt;device>.

Examples:

unmount cart
<pre>  Unmounts any file mounted on device named cart.</pre>
<br>
------------X5ScjEJDEcKR21fOfR0crs--
