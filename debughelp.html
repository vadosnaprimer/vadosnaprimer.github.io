<!DOCTYPE html>
<html>
<head>
<title>MAME Debugger Help</title>
</head>
<body>
<a name="Top"></a>
MAME Debugger Help<br>
&emsp;<font face="courier new" color=#000080 size=2>  help [&lt;topic>]</font> -- get help on a particular topic<br>
<br>
Topics:<br>
&emsp;<font face="courier new" color=#000080 size=2>  General</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Memory</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Execution</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Breakpoints</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Watchpoints</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Registerpoints</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Expressions</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Comments</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Cheats</font><br>
&emsp;<font face="courier new" color=#000080 size=2>  Image</font><br>
<br>
<a href="#bpclear">bpclear</a><br>
<a href="#bpdisable">bpdisable</a><br>
<a href="#bpenable">bpenable</a><br>
<a href="#bplist">bplist</a><br>
<a href="#bpset">bpset</a><br>
<a href="#breakpoints">breakpoints</a><br>
<a href="#cheatinit">cheatinit</a><br>
<a href="#cheatlist">cheatlist</a><br>
<a href="#cheatnext">cheatnext</a><br>
<a href="#cheatnextf">cheatnextf</a><br>
<a href="#cheatrange">cheatrange</a><br>
<a href="#cheats">cheats</a><br>
<a href="#cheatundo">cheatundo</a><br>
<a href="#comadd">comadd</a><br>
<a href="#comdelete">comdelete</a><br>
<a href="#comlist">comlist</a><br>
<a href="#comments">comments</a><br>
<a href="#commit">commit</a><br>
<a href="#comsave">comsave</a><br>
<a href="#dasm">dasm</a><br>
<a href="#do">do</a><br>
<a href="#dump">dump</a><br>
<a href="#execution">execution</a><br>
<a href="#expressions">expressions</a><br>
<a href="#find">find</a><br>
<a href="#focus">focus</a><br>
<a href="#general">general</a><br>
<a href="#gint">gint</a><br>
<a href="#go">go</a><br>
<a href="#gtime">gtime</a><br>
<a href="#gvblank">gvblank</a><br>
<a href="#hardreset">hardreset</a><br>
<a href="#helphtml">helphtml</a><br>
<a href="#hotspot">hotspot</a><br>
<a href="#ignore">ignore</a><br>
<a href="#image">image</a><br>
<a href="#images">images</a><br>
<a href="#load">load</a><br>
<a href="#logerror">logerror</a><br>
<a href="#map">map</a><br>
<a href="#memdump">memdump</a><br>
<a href="#memory">memory</a><br>
<a href="#mount">mount</a><br>
<a href="#next">next</a><br>
<a href="#observe">observe</a><br>
<a href="#out">out</a><br>
<a href="#over">over</a><br>
<a href="#pcatmem">pcatmem</a><br>
<a href="#print">print</a><br>
<a href="#printf">printf</a><br>
<a href="#quit">quit</a><br>
<a href="#registerpoints">registerpoints</a><br>
<a href="#rewind[rw]">rewind[rw]</a><br>
<a href="#rpclear">rpclear</a><br>
<a href="#rpdisable">rpdisable</a><br>
<a href="#rpenable">rpenable</a><br>
<a href="#rplist">rplist</a><br>
<a href="#rpset">rpset</a><br>
<a href="#save">save</a><br>
<a href="#snap">snap</a><br>
<a href="#softreset">softreset</a><br>
<a href="#source">source</a><br>
<a href="#stateload[sl]">stateload[sl]</a><br>
<a href="#statesave[ss]">statesave[ss]</a><br>
<a href="#step">step</a><br>
<a href="#symlist">symlist</a><br>
<a href="#trace">trace</a><br>
<a href="#traceflush">traceflush</a><br>
<a href="#tracelog">tracelog</a><br>
<a href="#traceover">traceover</a><br>
<a href="#tracesym">tracesym</a><br>
<a href="#trackmem">trackmem</a><br>
<a href="#trackpc">trackpc</a><br>
<a href="#unmount">unmount</a><br>
<a href="#watchpoints">watchpoints</a><br>
<a href="#wpclear">wpclear</a><br>
<a href="#wpdisable">wpdisable</a><br>
<a href="#wpenable">wpenable</a><br>
<a href="#wplist">wplist</a><br>
<a href="#wpset">wpset</a><br>
<br>
<a href="#Top">Up</a>
<a name="general"><h3>general</h3></a>

General Debugger Help<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  help [&lt;topic>]</font> -- get help on a particular topic<br>
&emsp;<font face="courier new" color=#000080 size=2>  helphtml &lt;filename></font> -- print all debugger help to an html file<br>
&emsp;<font face="courier new" color=#000080 size=2>  do &lt;expression></font> -- evaluates the given expression<br>
&emsp;<font face="courier new" color=#000080 size=2>  symlist [&lt;cpu>]</font> -- lists registered symbols<br>
&emsp;<font face="courier new" color=#000080 size=2>  softreset</font> -- executes a soft reset<br>
&emsp;<font face="courier new" color=#000080 size=2>  hardreset</font> -- executes a hard reset<br>
&emsp;<font face="courier new" color=#000080 size=2>  print &lt;item>[,...]</font> -- prints one or more &lt;item>s to the console<br>
&emsp;<font face="courier new" color=#000080 size=2>  printf &lt;format>[,&lt;item>[,...]]</font> -- prints one or more &lt;item>s to the console using &lt;format><br>
&emsp;<font face="courier new" color=#000080 size=2>  logerror &lt;format>[,&lt;item>[,...]]</font> -- outputs one or more &lt;item>s to the error.log<br>
&emsp;<font face="courier new" color=#000080 size=2>  tracelog &lt;format>[,&lt;item>[,...]]</font> -- outputs one or more &lt;item>s to the trace file using &lt;format><br>
&emsp;<font face="courier new" color=#000080 size=2>  tracesym &lt;item>[,...]]</font> -- outputs one or more &lt;item>s to the trace file<br>
&emsp;<font face="courier new" color=#000080 size=2>  history [&lt;cpu>,&lt;length>]</font> -- outputs a brief history of visited opcodes<br>
&emsp;<font face="courier new" color=#000080 size=2>  trackpc [&lt;bool>,&lt;cpu>,&lt;bool>]</font> -- visually track visited opcodes [boolean to turn on and off, for the given cpu, clear]<br>
&emsp;<font face="courier new" color=#000080 size=2>  trackmem [&lt;bool>,&lt;bool>]</font> -- record which PC writes to each memory address [boolean to turn on and off, clear]<br>
&emsp;<font face="courier new" color=#000080 size=2>  pcatmemp &lt;address>[,&lt;cpu>]</font> -- query which PC wrote to a given program memory address for the current CPU<br>
&emsp;<font face="courier new" color=#000080 size=2>  pcatmemd &lt;address>[,&lt;cpu>]</font> -- query which PC wrote to a given data memory address for the current CPU<br>
&emsp;<font face="courier new" color=#000080 size=2>  pcatmemi &lt;address>[,&lt;cpu>]</font> -- query which PC wrote to a given I/O memory address for the current CPU (Note: you can also query this info by right clicking in a memory window)<br>
&emsp;<font face="courier new" color=#000080 size=2>  rewind[rw]</font> -- go back in time by loading the most recent rewind state<br>
&emsp;<font face="courier new" color=#000080 size=2>  statesave[ss] &lt;filename></font> -- save a state file for the current driver<br>
&emsp;<font face="courier new" color=#000080 size=2>  stateload[sl] &lt;filename></font> -- load a state file for the current driver<br>
&emsp;<font face="courier new" color=#000080 size=2>  snap [&lt;filename>]</font> -- save a screen snapshot<br>
&emsp;<font face="courier new" color=#000080 size=2>  source &lt;filename></font> -- reads commands from &lt;filename> and executes them one by one<br>

<br>
<a href="#Top">Up</a>
<a name="memory"><h3>memory</h3></a>

Memory Commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  dasm &lt;filename>,&lt;address>,&lt;length>[,&lt;opcodes>[,&lt;cpu>]]</font> -- disassemble to the given file<br>
&emsp;<font face="courier new" color=#000080 size=2>  f[ind] &lt;address>,&lt;length>[,&lt;data>[,...]]</font> -- search program memory for data<br>
&emsp;<font face="courier new" color=#000080 size=2>  f[ind]d &lt;address>,&lt;length>[,&lt;data>[,...]]</font> -- search data memory for data<br>
&emsp;<font face="courier new" color=#000080 size=2>  f[ind]i &lt;address>,&lt;length>[,&lt;data>[,...]]</font> -- search I/O memory for data<br>
&emsp;<font face="courier new" color=#000080 size=2>  dump &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&lt;ascii>[,&lt;cpu>]]]</font> -- dump program memory as text<br>
&emsp;<font face="courier new" color=#000080 size=2>  dumpd &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&lt;ascii>[,&lt;cpu>]]]</font> -- dump data memory as text<br>
&emsp;<font face="courier new" color=#000080 size=2>  dumpi &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&lt;ascii>[,&lt;cpu>]]]</font> -- dump I/O memory as text<br>
&emsp;<font face="courier new" color=#000080 size=2>  save &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>]</font> -- save binary program memory to the given file<br>
&emsp;<font face="courier new" color=#000080 size=2>  saved &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>]</font> -- save binary data memory to the given file<br>
&emsp;<font face="courier new" color=#000080 size=2>  savei &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>]</font> -- save binary I/O memory to the given file<br>
&emsp;<font face="courier new" color=#000080 size=2>  load &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>]</font> -- load binary program memory from the given file<br>
&emsp;<font face="courier new" color=#000080 size=2>  loadd &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>]</font> -- load binary data memory from the given file<br>
&emsp;<font face="courier new" color=#000080 size=2>  loadi &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>]</font> -- load binary I/O memory from the given file<br>
&emsp;<font face="courier new" color=#000080 size=2>  map &lt;address></font> -- map logical program address to physical address and bank<br>
&emsp;<font face="courier new" color=#000080 size=2>  mapd &lt;address></font> -- map logical data address to physical address and bank<br>

<br>
<a href="#Top">Up</a>
<a name="execution"><h3>execution</h3></a>

Execution Commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  s[tep] [&lt;count>=1]</font> -- single steps for &lt;count> instructions (F11)<br>
&emsp;<font face="courier new" color=#000080 size=2>  o[ver] [&lt;count>=1]</font> -- single steps over &lt;count> instructions (F10)<br>
&emsp;<font face="courier new" color=#000080 size=2>  out</font> -- single steps until the current subroutine/exception handler is exited (Shift-F11)<br>
&emsp;<font face="courier new" color=#000080 size=2>  g[o] [&lt;address>]</font> -- resumes execution, sets temp breakpoint at &lt;address> (F5)<br>
&emsp;<font face="courier new" color=#000080 size=2>  gi[nt] [&lt;irqline>]</font> -- resumes execution, setting temp breakpoint if &lt;irqline> is taken (F7)<br>
&emsp;<font face="courier new" color=#000080 size=2>  gt[ime] &lt;milliseconds></font> -- resumes execution until the given delay has elapsed<br>
&emsp;<font face="courier new" color=#000080 size=2>  gv[blank]</font> -- resumes execution, setting temp breakpoint on the next VBLANK (F8)<br>
&emsp;<font face="courier new" color=#000080 size=2>  n[ext]</font> -- executes until the next CPU switch (F6)<br>
&emsp;<font face="courier new" color=#000080 size=2>  focus &lt;cpu></font> -- focuses debugger only on &lt;cpu><br>
&emsp;<font face="courier new" color=#000080 size=2>  ignore [&lt;cpu>[,&lt;cpu>[,...]]]</font> -- stops debugging on &lt;cpu><br>
&emsp;<font face="courier new" color=#000080 size=2>  observe [&lt;cpu>[,&lt;cpu>[,...]]]</font> -- resumes debugging on &lt;cpu><br>
&emsp;<font face="courier new" color=#000080 size=2>  trace {&lt;filename>|OFF}[,&lt;cpu>[,&lt;detectloops>[,&lt;action>]]]</font> -- trace the given CPU to a file (defaults to active CPU)<br>
&emsp;<font face="courier new" color=#000080 size=2>  traceover {&lt;filename>|OFF}[,&lt;cpu>[,&lt;detectloops>[,&lt;action>]]]</font> -- trace the given CPU to a file, but skip subroutines (defaults to active CPU)<br>

<br>
<a href="#Top">Up</a>
<a name="breakpoints"><h3>breakpoints</h3></a>

Breakpoint Commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bp[set] &lt;address>[,&lt;condition>[,&lt;action>]]</font> -- sets breakpoint at &lt;address><br>
&emsp;<font face="courier new" color=#000080 size=2>  bpclear [&lt;bpnum>]</font> -- clears a given breakpoint or all if no &lt;bpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpdisable [&lt;bpnum>]</font> -- disables a given breakpoint or all if no &lt;bpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpenable [&lt;bpnum>]</font> -- enables a given breakpoint or all if no &lt;bpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  bplist</font> -- lists all the breakpoints<br>

<br>
<a href="#Top">Up</a>
<a name="watchpoints"><h3>watchpoints</h3></a>

Watchpoint Commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wp[set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>[,&lt;action>]]</font> -- sets program space watchpoint<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpd[set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>[,&lt;action>]]</font> -- sets data space watchpoint<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpi[set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>[,&lt;action>]]</font> -- sets I/O space watchpoint<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpclear [&lt;wpnum>]</font> -- clears a given watchpoint or all if no &lt;wpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpdisable [&lt;wpnum>]</font> -- disables a given watchpoint or all if no &lt;wpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpenable [&lt;wpnum>]</font> -- enables a given watchpoint or all if no &lt;wpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  wplist</font> -- lists all the watchpoints<br>

<br>
<a href="#Top">Up</a>
<a name="registerpoints"><h3>registerpoints</h3></a>

Registerpoint Commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rp[set] {&lt;condition>}[,&lt;action>]</font> -- sets a registerpoint to trigger on &lt;condition><br>
&emsp;<font face="courier new" color=#000080 size=2>  rpclear [&lt;rpnum>]</font> -- clears a given registerpoint or all if no &lt;rpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpdisable [&lt;rpnum>]</font> -- disabled a given registerpoint or all if no &lt;rpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpenable [&lt;rpnum>] </font> -- enables a given registerpoint or all if no &lt;rpnum> specified<br>
&emsp;<font face="courier new" color=#000080 size=2>  rplist</font> -- lists all the registerpoints<br>

<br>
<a href="#Top">Up</a>
<a name="expressions"><h3>expressions</h3></a>

Expressions can be used anywhere a numeric parameter is expected. The syntax for expressions is very close to standard C-style syntax with full operator ordering and parentheses. There are a few operators missing (notably the trinary ? : operator), and a few new ones (memory accessors). The table below lists all the operators in their order, highest precedence operators first.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  ( )</font> : standard parentheses<br>
&emsp;<font face="courier new" color=#000080 size=2>  ++ --</font> : postfix increment/decrement<br>
&emsp;<font face="courier new" color=#000080 size=2>  ++ -- ~ ! - + b@ w@ d@ q@</font> : prefix inc/dec, binary NOT, logical NOT, unary +/-, memory access<br>
&emsp;<font face="courier new" color=#000080 size=2>  * / %</font> : multiply, divide, modulus<br>
&emsp;<font face="courier new" color=#000080 size=2>  + -</font> : add, subtract<br>
&emsp;<font face="courier new" color=#000080 size=2>  &lt;&lt; >></font> : shift left/right<br>
&emsp;<font face="courier new" color=#000080 size=2>  &lt; &lt;= > >=</font> : less than, less than or equal, greater than, greater than or equal<br>
&emsp;<font face="courier new" color=#000080 size=2>  == !=</font> : equal, not equal<br>
&emsp;<font face="courier new" color=#000080 size=2>  &</font> : binary AND<br>
&emsp;<font face="courier new" color=#000080 size=2>  ^</font> : binary XOR<br>
&emsp;<font face="courier new" color=#000080 size=2>  |</font> : binary OR<br>
&emsp;<font face="courier new" color=#000080 size=2>  &&</font> : logical AND<br>
&emsp;<font face="courier new" color=#000080 size=2>  ||</font> : logical OR<br>
&emsp;<font face="courier new" color=#000080 size=2>  = *= /= %= += -= &lt;&lt;= >>= &= |= ^=</font> : assignment<br>
&emsp;<font face="courier new" color=#000080 size=2>  ,</font> : separate terms, function parameters<br>
<br>
These are the differences from C behaviors. First, All math is performed on full 64-bit unsigned values, so things like a &lt; 0 won't work as expected. Second, the logical operators && and || do not have short-circuit properties -- both halves are always evaluated. Finally, the new memory operators work like this: b@&lt;addr> refers to the byte read from &lt;addr>. Similarly, w@ refers to a word in memory, d@ refers to a dword in memory, and q@ refers to a qword in memory. The memory operators can be used as both lvalues and rvalues, so you can write b@100 = ff to store a byte in memory. By default these operators read from the program memory space, but you can override that by prefixing them with a 'd' or an 'i'. So dw@300 refers to data memory word at address 300 and id@400 refers to an I/O memory dword at address 400.<br>

<br>
<a href="#Top">Up</a>
<a name="comments"><h3>comments</h3></a>

Code annotation commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  comadd[//] &lt;address>,&lt;comment></font> -- adds a comment to the disassembled code at given address<br>
&emsp;<font face="courier new" color=#000080 size=2>  comdelete &lt;address></font> -- removes a comment from the given address<br>
&emsp;<font face="courier new" color=#000080 size=2>  comsave</font> -- save the current comments to a file<br>
&emsp;<font face="courier new" color=#000080 size=2>  comlist</font> -- print currently available comments from file<br>
&emsp;<font face="courier new" color=#000080 size=2>  commit[/*] &lt;address>,&lt;comment></font> -- gives a bulk comadd then comsave command<br>

<br>
<a href="#Top">Up</a>
<a name="cheats"><h3>cheats</h3></a>

Cheat Commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatinit [&lt;address>,&lt;length>[,&lt;cpu>]]</font> -- initialize the cheat search to the selected memory area<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatrange &lt;address>,&lt;length></font> -- add to the cheat search the selected memory area<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatnext &lt;condition>[,&lt;comparisonvalue>]</font> -- continue cheat search comparing with the last value<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatnextf &lt;condition>[,&lt;comparisonvalue>]</font> -- continue cheat search comparing with the first value<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatlist [&lt;filename>]</font> -- show the list of cheat search matches or save them to &lt;filename><br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatundo</font> -- undo the last cheat search (state only)<br>

<br>
<a href="#Top">Up</a>
<a name="image"><h3>image</h3></a>

Image Commands<br>
Type help &lt;command> for further details on each command<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  images</font> -- lists all image devices and mounted files<br>
&emsp;<font face="courier new" color=#000080 size=2>  mount &lt;device>,&lt;filename></font> -- mounts file to named device<br>
&emsp;<font face="courier new" color=#000080 size=2>  unmount &lt;device></font> -- unmounts file from named device<br>

<br>
<a href="#Top">Up</a>
<a name="do"><h3>do</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  do &lt;expression></font><br>
<br>
The do command simply evaluates the given &lt;expression>. This is typically used to set or modify variables.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  do pc = 0</font><br>
Sets the register 'pc' to 0.<br>

<br>
<a href="#Top">Up</a>
<a name="symlist"><h3>symlist</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  symlist [&lt;cpu>]</font><br>
<br>
Lists registered symbols. If &lt;cpu> is not specified, then symbols in the global symbol table are displayed; otherwise, the symbols for &lt;cpu>'s specific CPU are displayed. Symbols are listed alphabetically. Read-only symbols are flagged with an asterisk.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  symlist</font><br>
Displays the global symbol table.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  symlist 2</font><br>
Displays the symbols specific to CPU #2.<br>

<br>
<a href="#Top">Up</a>
<a name="softreset"><h3>softreset</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  softreset</font><br>
<br>
Executes a soft reset.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  softreset</font><br>
Executes a soft reset.<br>

<br>
<a href="#Top">Up</a>
<a name="hardreset"><h3>hardreset</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  hardreset</font><br>
<br>
Executes a hard reset.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  hardreset</font><br>
Executes a hard reset.<br>

<br>
<a href="#Top">Up</a>
<a name="print"><h3>print</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  print &lt;item>[,...]</font><br>
<br>
The print command prints the results of one or more expressions to the debugger console as hexadecimal values.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  print pc</font><br>
Prints the value of 'pc' to the console as a hex number.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  print a,b,a+b</font><br>
Prints a, b, and the value of a+b to the console as hex numbers.<br>

<br>
<a href="#Top">Up</a>
<a name="printf"><h3>printf</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  printf &lt;format>[,&lt;item>[,...]]</font><br>
<br>
The printf command performs a C-style printf to the debugger console. Only a very limited set of formatting options are available:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  %[0][&lt;n>]d</font> -- prints &lt;item> as a decimal value with optional digit count and zero-fill<br>
&emsp;<font face="courier new" color=#000080 size=2>  %[0][&lt;n>]x</font> -- prints &lt;item> as a hexadecimal value with optional digit count and zero-fill<br>
<br>
All remaining formatting options are ignored. Use %% together to output a % character. Multiple lines can be printed by embedding a \n in the text.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  printf "PC=%04X",pc</font><br>
Prints PC=&lt;pcval> where &lt;pcval> is displayed in hexadecimal with 4 digits with zero-fill.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  printf "A=%d, B=%d\nC=%d",a,b,a+b</font><br>
Prints A=&lt;aval>, B=&lt;bval> on one line, and C=&lt;a+bval> on a second line.<br>

<br>
<a href="#Top">Up</a>
<a name="logerror"><h3>logerror</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  logerror &lt;format>[,&lt;item>[,...]]</font><br>
<br>
The logerror command performs a C-style printf to the error log. Only a very limited set of formatting options are available:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  %[0][&lt;n>]d</font> -- logs &lt;item> as a decimal value with optional digit count and zero-fill<br>
&emsp;<font face="courier new" color=#000080 size=2>  %[0][&lt;n>]x</font> -- logs &lt;item> as a hexadecimal value with optional digit count and zero-fill<br>
<br>
All remaining formatting options are ignored. Use %% together to output a % character. Multiple lines can be printed by embedding a \n in the text.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  logerror "PC=%04X",pc</font><br>
Logs PC=&lt;pcval> where &lt;pcval> is displayed in hexadecimal with 4 digits with zero-fill.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  logerror "A=%d, B=%d\nC=%d",a,b,a+b</font><br>
Logs A=&lt;aval>, B=&lt;bval> on one line, and C=&lt;a+bval> on a second line.<br>

<br>
<a href="#Top">Up</a>
<a name="tracelog"><h3>tracelog</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  tracelog &lt;format>[,&lt;item>[,...]]</font><br>
<br>
The tracelog command performs a C-style printf and routes the output to the currently open trace file (see the 'trace' command for details). If no file is currently open, tracelog does nothing. Only a very limited set of formatting options are available. See the 'printf' help for details.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  tracelog "PC=%04X",pc</font><br>
Outputs PC=&lt;pcval> where &lt;pcval> is displayed in hexadecimal with 4 digits with zero-fill.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  printf "A=%d, B=%d\nC=%d",a,b,a+b</font><br>
Outputs A=&lt;aval>, B=&lt;bval> on one line, and C=&lt;a+bval> on a second line.<br>

<br>
<a href="#Top">Up</a>
<a name="tracesym"><h3>tracesym</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  tracesym &lt;item>[,...]</font><br>
<br>
The tracesym command prints the specified symbols and routes the output to the currently open trace file (see the 'trace' command for details). If no file is currently open, tracesym does nothing. <br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  tracelog pc</font><br>
Outputs PC=&lt;pcval> where &lt;pcval> is displayed in the default format.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  printf a,b</font><br>
Outputs A=&lt;aval>, B=&lt;bval> on one line.<br>

<br>
<a href="#Top">Up</a>
<a name="trackpc"><h3>trackpc</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  trackpc [&lt;bool>,&lt;cpu>,&lt;bool>]</font><br>
<br>
The trackpc command displays which program counters have already been visited in all disassembler windows. The first boolean argument toggles the process on and off.  The second argument is a cpu selector; if no cpu is specified, the current cpu is automatically selected.  The third argument is a boolean denoting if the existing data should be cleared or not.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trackpc 1</font><br>
Begin tracking the current cpu's pc.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trackpc 1, 0, 1</font><br>
Continue tracking pc on cpu 0, but clear existing track info.<br>

<br>
<a href="#Top">Up</a>
<a name="trackmem"><h3>trackmem</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  trackmem [&lt;bool>,&lt;cpu>,&lt;bool>]</font><br>
<br>
The trackmem command logs the PC at each time a memory address is written to.  The first boolean argument toggles the process on and off.  The second argument is a cpu selector; if no cpu is specified, the current cpu is automatically selected. The third argument  is a boolean denoting if the existing data should be cleared or not.  Please refer to the pcatmem command for information on how to retrieve this data.  Also, right clicking in a memory window will display the logged PC for the given address.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trackmem</font><br>
Begin tracking the current CPU's pc.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trackmem 1, 0, 1</font><br>
Continue tracking memory writes on cpu 0, but clear existing track info.<br>

<br>
<a href="#Top">Up</a>
<a name="pcatmem"><h3>pcatmem</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  pcatmem(p/d/i) &lt;address>[,&lt;cpu>]</font><br>
<br>
The pcatmem command returns which PC wrote to a given memory address for the current CPU. The first argument is the requested address.  The second argument is a cpu selector; if no cpu is specified, the current cpu is automatically selected.  Right clicking in a memory window will also display the logged PC for the given address.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  pcatmem 400000</font><br>
Print which PC wrote this CPU's memory location 0x400000.<br>

<br>
<a href="#Top">Up</a>
<a name="helphtml"><h3>helphtml</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  helphtml &lt;filename></font><br>
<br>
The helphtml command prints all the contents of debugger help to an html file.  The .html extension is not necessary, as it gets automatically appended if it's not present in the provided filename.<br>

<br>
<a href="#Top">Up</a>
<a name="rewind[rw]"><h3>rewind[rw]</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  rewind[rw]</font><br>
<br>
The rewind command loads the most recent RAM-based state.  Rewind states, when enabled, are saved when "step", "over", or "out" command gets executed, storing the machine state as of the moment before actually stepping.  Consecutively loading rewind states can work like reverse execution.  Depending on which steps forward were taken previously, the bahavior can be similar to GDB's "reverse-stepi" or "reverse-next".  All output for this command is currently echoed into the running machine window.  Previous memory and PC tracking statistics are cleared, actual reverse execution does not occur.<br>

<br>
<a href="#Top">Up</a>
<a name="statesave[ss]"><h3>statesave[ss]</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  statesave[ss] &lt;filename></font><br>
<br>
The statesave command creates a save state at this exact moment in time. The given state file gets written to the standard state directory (sta), and gets .sta to it - no file extension necessary.  All output for this command is currently echoed into the running machine window.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  statesave foo</font><br>
Writes file 'foo.sta' in the default state save directory.<br>

<br>
<a href="#Top">Up</a>
<a name="stateload[sl]"><h3>stateload[sl]</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  stateload[sl] &lt;filename></font><br>
<br>
The stateload command retrieves a save state from disk. The given state file gets read from the standard state directory (sta), and gets .sta to it - no file extension necessary.  All output for this command is currently echoed into the running machine window.  Previous memory and PC tracking statistics are cleared.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  stateload foo</font><br>
Reads file 'foo.sta' from the default state save directory.<br>

<br>
<a href="#Top">Up</a>
<a name="snap"><h3>snap</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  snap [[&lt;filename>], &lt;scrnum>]</font><br>
<br>
The snap command takes a snapshot of the current video display and saves it to the configured snapshot directory. If &lt;filename> is specified explicitly, a single screenshot for &lt;scrnum> is saved under the requested filename. If &lt;filename> is omitted, all screens are saved using the same default rules as the "save snapshot" key in MAME proper.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  snap</font><br>
Takes a snapshot of the current video screen and saves to the next non-conflicting filename in the configured snapshot directory.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  snap shinobi</font><br>
Takes a snapshot of the current video screen and saves it as 'shinobi.png' in the configured snapshot directory.<br>

<br>
<a href="#Top">Up</a>
<a name="source"><h3>source</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  source &lt;filename></font><br>
<br>
The source command reads in a set of debugger commands from a file and executes them one by one, similar to a batch file.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  source break_and_trace.cmd</font><br>
Reads in debugger commands from break_and_trace.cmd and executes them.<br>

<br>
<a href="#Top">Up</a>
<a name="quit"><h3>quit</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  quit</font><br>
<br>
The quit command exits MAME immediately.<br>

<br>
<a href="#Top">Up</a>
<a name="dasm"><h3>dasm</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  dasm &lt;filename>,&lt;address>,&lt;length>[,&lt;opcodes>[,&lt;cpu>]]</font><br>
<br>
The dasm command disassembles program memory to the file specified in the &lt;filename> parameter. &lt;address> indicates the address of the start of disassembly, and &lt;length> indicates how much memory to disassemble. The range &lt;address> through &lt;address>+&lt;length>-1 inclusive will be output to the file. By default, the raw opcode data is output with each line. The optional &lt;opcodes> parameter can be used to enable (1) or disable(0) this feature. Finally, you can disassemble code from another CPU by specifying the &lt;cpu> parameter.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  dasm venture.asm,0,10000</font><br>
Disassembles addresses 0-ffff in the current CPU, including raw opcode data, to the file 'venture.asm'.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  dasm harddriv.asm,3000,1000,0,2</font><br>
Disassembles addresses 3000-3fff from CPU #2, with no raw opcode data, to the file 'harddriv.asm'.<br>

<br>
<a href="#Top">Up</a>
<a name="find"><h3>find</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  f[ind][{d|i}] &lt;address>,&lt;length>[,&lt;data>[,...]]</font><br>
<br>
The find/findd/findi commands search through memory for the specified sequence of data. 'find' will search program space memory, while 'findd' will search data space memory and 'findi' will search I/O space memory. &lt;address> indicates the address to begin searching, and &lt;length> indicates how much memory to search. &lt;data> can either be a quoted string or a numeric value or expression or the wildcard character '?'. Strings by default imply a byte-sized search; non-string data is searched by default in the native word size of the CPU. To override the search size for non-strings, you can prefix the value with b. to force byte- sized search, w. for word-sized search, d. for dword-sized, and q. for qword-sized. Overrides are remembered, so if you want to search for a series of words, you need only to prefix the first value with a w. Note also that you can intermix sizes in order to perform more complex searches. The entire range &lt;address> through &lt;address>+&lt;length>-1  inclusive will be searched for the sequence, and all occurrences will be displayed.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  find 0,10000,"HIGH SCORE",0</font><br>
Searches the address range 0-ffff in the current CPU for the string "HIGH SCORE" followed by a 0 byte.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  findd 3000,1000,w.abcd,4567</font><br>
Searches the data memory address range 3000-3fff for the word-sized value abcd followed by the word-sized value 4567.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  find 0,8000,"AAR",d.0,"BEN",w.0</font><br>
Searches the address range 0000-7fff for the string "AAR" followed by a dword-sized 0 followed by the string "BEN", followed by a word-sized 0.<br>

<br>
<a href="#Top">Up</a>
<a name="dump"><h3>dump</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  dump[{d|i}] &lt;filename>,&lt;address>,&lt;length>[,&lt;size>[,&lt;ascii>[,&lt;cpu>]]]</font><br>
<br>
The dump/dumpd/dumpi commands dump memory to the text file specified in the &lt;filename> parameter. 'dump' will dump program space memory, while 'dumpd' will dump data space memory and 'dumpi' will dump I/O space memory. &lt;address> indicates the address of the start of dumping, and &lt;length> indicates how much memory to dump. The range &lt;address> through &lt;address>+&lt;length>-1 inclusive will be output to the file. By default, the data will be output in byte format, unless the underlying address space is word/dword/qword-only. You can override this by specifying the &lt;size> parameter, which can be used to group the data in 1, 2, 4 or 8-byte chunks. The optional &lt;ascii> parameter can be used to enable (1) or disable (0) the output of ASCII characters to the right of each line; by default, this is enabled. Finally, you can dump memory from another CPU by specifying the &lt;cpu> parameter.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  dump venture.dmp,0,10000</font><br>
Dumps addresses 0-ffff in the current CPU in 1-byte chunks, including ASCII data, to the file 'venture.dmp'.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  dumpd harddriv.dmp,3000,1000,4,0,3</font><br>
Dumps data memory addresses 3000-3fff from CPU #3 in 4-byte chunks, with no ASCII data, to the file 'harddriv.dmp'.<br>

<br>
<a href="#Top">Up</a>
<a name="save"><h3>save</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  save[{d|i}] &lt;filename>,&lt;address>,&lt;length>[,&lt;cpu>]</font><br>
<br>
The save/saved/savei commands save raw memory to the binary file specified in the &lt;filename> parameter. 'save' will save program space memory, while 'saved' will save data space memory and 'savei' will save I/O space memory. &lt;address> indicates the address of the start of saving, and &lt;length> indicates how much memory to save. The range &lt;address> through &lt;address>+&lt;length>-1 inclusive will be output to the file. You can also save memory from another CPU by specifying the &lt;cpu> parameter.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  save venture.bin,0,10000</font><br>
Saves addresses 0-ffff in the current CPU to the binary file 'venture.bin'.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  saved harddriv.bin,3000,1000,3</font><br>
Saves data memory addresses 3000-3fff from CPU #3 to the binary file 'harddriv.bin'.<br>

<br>
<a href="#Top">Up</a>
<a name="load"><h3>load</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  load[{d|i}] &lt;filename>,&lt;address>[,&lt;length>,&lt;cpu>]</font><br>
<br>
The load/loadd/loadi commands load raw memory from the binary file specified in the &lt;filename> parameter. 'load' will load program space memory, while 'loadd' will load data space memory and 'loadi' will load I/O space memory. &lt;address> indicates the address of the start of saving, and &lt;length> indicates how much memory to load. The range &lt;address> through &lt;address>+&lt;length>-1 inclusive will be read in from the file. If you specify &lt;length> = 0 or a length greater than the total length of the file it will load the entire contents of the file and no more. You can also load memory from another CPU by specifying the &lt;cpu> parameter.<br>
NOTE: This will only actually write memory that is possible to overwrite in the Memory Window<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  load venture.bin,0,10000</font><br>
Loads addresses 0-ffff in the current CPU from the binary file 'venture.bin'.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  loadd harddriv.bin,3000,1000,3</font><br>
Loads data memory addresses 3000-3fff from CPU #3 from the binary file 'harddriv.bin'.<br>

<br>
<a href="#Top">Up</a>
<a name="step"><h3>step</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  s[tep] [&lt;count>=1]</font><br>
<br>
The step command single steps one or more instructions in the currently executing CPU. By default, step executes one instruction each time it is issued. You can also tell step to step multiple instructions by including the optional &lt;count> parameter.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  s</font><br>
Steps forward one instruction on the current CPU.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  step 4</font><br>
Steps forward four instructions on the current CPU.<br>

<br>
<a href="#Top">Up</a>
<a name="over"><h3>over</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  o[ver] [&lt;count>=1]</font><br>
<br>
The over command single steps "over" one or more instructions in the currently executing CPU, stepping over subroutine calls and exception handler traps and counting them as a single instruction. Note that when stepping over a subroutine call, code may execute on other CPUs before the subroutine call completes. By default, over executes one instruction each time it is issued. You can also tell step to step multiple instructions by including the optional &lt;count> parameter.<br>
<br>
Note that the step over functionality may not be implemented on all CPU types. If it is not implemented, then 'over' will behave exactly like 'step'.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  o</font><br>
Steps forward over one instruction on the current CPU.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  over 4</font><br>
Steps forward over four instructions on the current CPU.<br>

<br>
<a href="#Top">Up</a>
<a name="out"><h3>out</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  out</font><br>
<br>
The out command single steps until it encounters a return from subroutine or return from exception instruction. Note that because it detects return from exception conditions, if you attempt to step out of a subroutine and an interrupt/exception occurs before you hit the end, then you may stop prematurely at the end of the exception handler.<br>
<br>
Note that the step out functionality may not be implemented on all CPU types. If it is not implemented, then 'out' will behave exactly like 'step'.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  out</font><br>
Steps until the current subroutine or exception handler returns.<br>

<br>
<a href="#Top">Up</a>
<a name="go"><h3>go</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  g[o] [&lt;address>]</font><br>
<br>
The go command resumes execution of the current code. Control will not be returned to the debugger until a breakpoint or watchpoint is hit, or until you manually break in using the assigned key. The go command takes an optional &lt;address> parameter which is a temporary unconditional breakpoint that is set before executing, and automatically removed when hit. <br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  g</font><br>
Resume execution until the next break/watchpoint or until a manual break.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  g 1234</font><br>
Resume execution, stopping at address 1234 unless something else stops us first.<br>

<br>
<a href="#Top">Up</a>
<a name="gvblank"><h3>gvblank</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  gv[blank]</font><br>
<br>
The gvblank command resumes execution of the current code. Control will not be returned to the debugger until a breakpoint or watchpoint is hit, or until the next VBLANK occurs in the emulator.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  gv</font><br>
Resume execution until the next break/watchpoint or until the next VBLANK.<br>

<br>
<a href="#Top">Up</a>
<a name="gint"><h3>gint</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  gi[nt] [&lt;irqline>]</font><br>
<br>
The gint command resumes execution of the current code. Control will not be returned to the debugger until a breakpoint or watchpoint is hit, or until an IRQ is asserted and acknowledged on the current CPU. You can specify &lt;irqline> if you wish to stop execution only on a particular IRQ line being asserted and acknowledged. If &lt;irqline> is omitted, then any IRQ line will stop execution.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  gi</font><br>
Resume execution until the next break/watchpoint or until any IRQ is asserted and acknowledged on the current CPU.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  gint 4</font><br>
Resume execution until the next break/watchpoint or until IRQ line 4 is asserted and acknowledged on the current CPU.<br>

<br>
<a href="#Top">Up</a>
<a name="gtime"><h3>gtime</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  gt[ime] &lt;milliseconds></font><br>
<br>
The gtime command resumes execution of the current code. Control will not be returned to the debugger until a specified delay has elapsed. The delay is in milliseconds.<br>
<br>
Example:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  gtime #10000</font><br>
Resume execution for ten seconds<br>

<br>
<a href="#Top">Up</a>
<a name="next"><h3>next</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  n[ext]</font><br>
<br>
The next command resumes execution and continues executing until the next time a different CPU is scheduled. Note that if you have used 'ignore' to ignore certain CPUs, you will not stop until a non-'ignore'd CPU is scheduled.<br>

<br>
<a href="#Top">Up</a>
<a name="focus"><h3>focus</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  focus &lt;cpu></font><br>
<br>
Sets the debugger focus exclusively to the given &lt;cpu>. This is equivalent to specifying 'ignore' on all other CPUs.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  focus 1</font><br>
Focus exclusively CPU #1 while ignoring all other CPUs when using the debugger.<br>

<br>
<a href="#Top">Up</a>
<a name="ignore"><h3>ignore</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  ignore [&lt;cpu>[,&lt;cpu>[,...]]]</font><br>
<br>
Ignores the specified &lt;cpu> in the debugger. This means that you won't ever see execution on that CPU, nor will you be able to set breakpoints on that CPU. To undo this change use the 'observe' command. You can specify multiple &lt;cpu>s in a single command. Note also that you are not permitted to ignore all CPUs; at least one must be active at all times.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  ignore 1</font><br>
Ignore CPU #1 when using the debugger.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  ignore 2,3,4</font><br>
Ignore CPU #2, #3 and #4 when using the debugger.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  ignore</font><br>
List the CPUs that are currently ignored.<br>

<br>
<a href="#Top">Up</a>
<a name="observe"><h3>observe</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  observe [&lt;cpu>[,&lt;cpu>[,...]]]</font><br>
<br>
Re-enables interaction with the specified &lt;cpu> in the debugger. This command undoes the effects of the 'ignore' command. You can specify multiple &lt;cpu>s in a single command.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  observe 1</font><br>
Stop ignoring CPU #1 when using the debugger.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  observe 2,3,4</font><br>
Stop ignoring CPU #2, #3 and #4 when using the debugger.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  observe</font><br>
List the CPUs that are currently observed.<br>

<br>
<a href="#Top">Up</a>
<a name="trace"><h3>trace</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  trace {&lt;filename>|OFF}[,&lt;cpu>[,[noloop|logerror][,&lt;action>]]]</font><br>
<br>
Starts or stops tracing of the execution of the specified &lt;cpu>. If &lt;cpu> is omitted, the currently active CPU is specified. When enabling tracing, specify the filename in the &lt;filename> parameter. To disable tracing, substitute the keyword 'off' for &lt;filename>. &lt;detectloops> should be either true or false. If 'noloop' is omitted, the trace will have loops detected and condensed to a single line. If 'noloop' is specified, the trace will contain every opcode as it is executed. If 'logerror' is specified, logerror output will augment the trace.  If you wish to log additional information on each trace, you can append an &lt;action> parameter which is a command that is executed before each trace is logged. Generally, this is used to include a 'tracelog' command. Note that you may need to embed the action within braces { } in order to prevent commas and semicolons from being interpreted as applying to the trace command itself.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace joust.tr</font><br>
Begin tracing the currently active CPU, logging output to joust.tr.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace dribling.tr,0</font><br>
Begin tracing the execution of CPU #0, logging output to dribling.tr.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace starswep.tr,0,noloop</font><br>
Begin tracing the execution of CPU #0, logging output to starswep.tr, with loop detection disabled.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace starswep.tr,0,logerror</font><br>
Begin tracing the execution of CPU #0, logging output (along with logerror output) to starswep.tr.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace starswep.tr,0,logerror|noloop</font><br>
Begin tracing the execution of CPU #0, logging output (along with logerror output) to starswep.tr, with loop detection disabled.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace >>pigskin.tr</font><br>
Begin tracing the currently active CPU, appending log output to pigskin.tr.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace off,0</font><br>
Turn off tracing on CPU #0.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  trace asteroid.tr,0,,{tracelog "A=%02X ",a}</font><br>
Begin tracing the execution of CPU #0, logging output to asteroid.tr. Before each line, output A=&lt;aval> to the tracelog.<br>

<br>
<a href="#Top">Up</a>
<a name="traceover"><h3>traceover</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  traceover {&lt;filename>|OFF}[,&lt;cpu>[,&lt;detectloops>[,&lt;action>]]]</font><br>
<br>
Starts or stops tracing of the execution of the specified &lt;cpu>. When tracing reaches a subroutine or call, tracing will skip over the subroutine. The same algorithm is used as is used in the step over command. This means that traceover will not work properly when calls are recusive or the return address is not immediately following the call instruction. If &lt;detectloops> should be either true or false. If &lt;detectloops> is true or omitted, the trace will have loops detected and condensed to a single line. If it is false, the trace will contain every opcode as it is executed. If &lt;cpu> is omitted, the currently active CPU is specified. When enabling tracing, specify the filename in the &lt;filename> parameter. To disable tracing, substitute the keyword 'off' for &lt;filename>. If you wish to log additional information on each trace, you can append an &lt;action> parameter which is a command that is executed before each trace is logged. Generally, this is used to include a 'tracelog' command. Note that you may need to embed the action within braces { } in order to prevent commas and semicolons from being interpreted as applying to the trace command itself.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  traceover joust.tr</font><br>
Begin tracing the currently active CPU, logging output to joust.tr.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  traceover dribling.tr,0</font><br>
Begin tracing the execution of CPU #0, logging output to dribling.tr.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  traceover starswep.tr,0,false</font><br>
Begin tracing the execution of CPU #0, logging output to starswep.tr, with loop detection disabled.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  traceover off,0</font><br>
Turn off tracing on CPU #0.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  traceover asteroid.tr,0,true,{tracelog "A=%02X ",a}</font><br>
Begin tracing the execution of CPU #0, logging output to asteroid.tr. Before each line, output A=&lt;aval> to the tracelog.<br>

<br>
<a href="#Top">Up</a>
<a name="traceflush"><h3>traceflush</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  traceflush</font><br>
<br>
Flushes all open trace files.<br>

<br>
<a href="#Top">Up</a>
<a name="bpset"><h3>bpset</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  bp[set] &lt;address>[,&lt;condition>[,&lt;action>]]</font><br>
<br>
Sets a new execution breakpoint at the specified &lt;address>. The optional &lt;condition> parameter lets you specify an expression that will be evaluated each time the breakpoint is hit. If the result of the expression is true (non-zero), the breakpoint will actually halt execution; otherwise, execution will continue with no notification. The optional &lt;action> parameter provides a command that is executed whenever the breakpoint is hit and the &lt;condition> is true. Note that you may need to embed the action within braces { } in order to prevent commas and semicolons from being interpreted as applying to the bpset command itself. Each breakpoint that is set is assigned an index which can be used in other breakpoint commands to reference this breakpoint.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bp 1234</font><br>
Set a breakpoint that will halt execution whenever the PC is equal to 1234.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bp 23456,a0 == 0 && a1 == 0</font><br>
Set a breakpoint that will halt execution whenever the PC is equal to 23456 AND the expression (a0 == 0 && a1 == 0) is true.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bp 3456,1,{printf "A0=%08X\n",a0; g}</font><br>
Set a breakpoint that will halt execution whenever the PC is equal to 3456. When this happens, print A0=&lt;a0val> and continue executing.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bp 45678,a0==100,{a0 = ff; g}</font><br>
Set a breakpoint that will halt execution whenever the PC is equal to 45678 AND the expression (a0 == 100) is true. When that happens, set a0 to ff and resume execution.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  temp0 = 0; bp 567890,++temp0 >= 10</font><br>
Set a breakpoint that will halt execution whenever the PC is equal to 567890 AND the expression (++temp0 >= 10) is true. This effectively breaks only after the breakpoint has been hit 16 times.<br>

<br>
<a href="#Top">Up</a>
<a name="bpclear"><h3>bpclear</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  bpclear [&lt;bpnum>]</font><br>
<br>
The bpclear command clears a breakpoint. If &lt;bpnum> is specified, only the requested breakpoint is cleared, otherwise all breakpoints are cleared.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpclear 3</font><br>
Clear breakpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpclear</font><br>
Clear all breakpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="bpdisable"><h3>bpdisable</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  bpdisable [&lt;bpnum>]</font><br>
<br>
The bpdisable command disables a breakpoint. If &lt;bpnum> is specified, only the requested breakpoint is disabled, otherwise all breakpoints are disabled. Note that disabling a breakpoint does not delete it, it just temporarily marks the breakpoint as inactive.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpdisable 3</font><br>
Disable breakpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpdisable</font><br>
Disable all breakpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="bpenable"><h3>bpenable</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  bpenable [&lt;bpnum>]</font><br>
<br>
The bpenable command enables a breakpoint. If &lt;bpnum> is specified, only the requested breakpoint is enabled, otherwise all breakpoints are enabled.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpenable 3</font><br>
Enable breakpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  bpenable</font><br>
Enable all breakpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="bplist"><h3>bplist</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  bplist</font><br>
<br>
The bplist command lists all the current breakpoints, along with their index and any conditions or actions attached to them.<br>

<br>
<a href="#Top">Up</a>
<a name="wpset"><h3>wpset</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  wp[{d|i}][set] &lt;address>,&lt;length>,&lt;type>[,&lt;condition>[,&lt;action>]]</font><br>
<br>
Sets a new watchpoint starting at the specified &lt;address> and extending for &lt;length>. The inclusive range of the watchpoint is &lt;address> through &lt;address> + &lt;length> - 1. The 'wpset' command sets a watchpoint on program memory; the 'wpdset' command sets a watchpoint on data memory; and the 'wpiset' sets a watchpoint on I/O memory. The &lt;type> parameter specifies which sort of accesses to trap on. It can be one of three values: 'r' for a read watchpoint 'w' for a write watchpoint, and 'rw' for a read/write watchpoint.<br>
<br>
The optional &lt;condition> parameter lets you specify an expression that will be evaluated each time the watchpoint is hit. If the result of the expression is true (non-zero), the watchpoint will actually halt execution; otherwise, execution will continue with no notification. The optional &lt;action> parameter provides a command that is executed whenever the watchpoint is hit and the &lt;condition> is true. Note that you may need to embed the action within braces { } in order to prevent commas and semicolons from being interpreted as applying to the wpset command itself. Each watchpoint that is set is assigned an index which can be used in other watchpoint commands to reference this watchpoint.<br>
<br>
In order to help &lt;condition> expressions, two variables are available. For all watchpoints, the variable 'wpaddr' is set to the address that actually triggered the watchpoint. For write watchpoints, the variable 'wpdata' is set to the data that is being written.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wp 1234,6,rw</font><br>
Set a watchpoint that will halt execution whenever a read or write occurs in the address range 1234-1239 inclusive.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wp 23456,a,w,wpdata == 1</font><br>
Set a watchpoint that will halt execution whenever a write occurs in the address range 23456-2345f AND the data written is equal to 1.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wp 3456,20,r,1,{printf "Read @ %08X\n",wpaddr; g}</font><br>
Set a watchpoint that will halt execution whenever a read occurs in the address range 3456-3475. When this happens, print Read @ &lt;wpaddr> and continue executing.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  temp0 = 0; wp 45678,1,w,wpdata==f0,{temp0++; g}</font><br>
Set a watchpoint that will halt execution whenever a write occurs to the address 45678 AND the value being written is equal to f0. When that happens, increment the variable temp0 and resume execution.<br>

<br>
<a href="#Top">Up</a>
<a name="wpclear"><h3>wpclear</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  wpclear [&lt;wpnum>]</font><br>
<br>
The wpclear command clears a watchpoint. If &lt;wpnum> is specified, only the requested watchpoint is cleared, otherwise all watchpoints are cleared.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpclear 3</font><br>
Clear watchpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpclear</font><br>
Clear all watchpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="wpdisable"><h3>wpdisable</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  wpdisable [&lt;wpnum>]</font><br>
<br>
The wpdisable command disables a watchpoint. If &lt;wpnum> is specified, only the requested watchpoint is disabled, otherwise all watchpoints are disabled. Note that disabling a watchpoint does not delete it, it just temporarily marks the watchpoint as inactive.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpdisable 3</font><br>
Disable watchpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpdisable</font><br>
Disable all watchpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="wpenable"><h3>wpenable</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  wpenable [&lt;wpnum>]</font><br>
<br>
The wpenable command enables a watchpoint. If &lt;wpnum> is specified, only the requested watchpoint is enabled, otherwise all watchpoints are enabled.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpenable 3</font><br>
Enable watchpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  wpenable</font><br>
Enable all watchpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="wplist"><h3>wplist</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  wplist</font><br>
<br>
The wplist command lists all the current watchpoints, along with their index and any conditions or actions attached to them.<br>

<br>
<a href="#Top">Up</a>
<a name="hotspot"><h3>hotspot</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  hotspot [&lt;cpu>,[&lt;depth>[,&lt;hits>]]]</font><br>
<br>
The hotspot command attempts to help locate hotspots in the code where speedup opportunities might be present. &lt;cpu>, which defaults to the currently active CPU, specified which processor's memory to track. &lt;depth>, which defaults to 64, controls the depth of the search buffer. The search buffer tracks the last &lt;depth> memory reads from unique PCs. The &lt;hits> parameter, which defaults to 250, specifies the minimum number of hits to report.<br>
<br>
The basic theory of operation is like this: each memory read is trapped by the debugger and logged in the search buffer according to the address which was read and the PC that executed the opcode. If the search buffer already contains a matching entry, that entry's count is incremented and the entry is moved to the top of the list. If the search buffer does not contain a matching entry, the entry from the bottom of the list is removed, and a new entry is created at the top with an initial count of 1. Entries which fall off the bottom are examined and if their count is larger than &lt;hits>, they are reported to the debugger console.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  hotspot 0,10</font><br>
Looks for hotspots on CPU 0 using a search buffer of 16 entries, reporting any entries which end up with 250 or more hits.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  hotspot 1,40,#1000</font><br>
Looks for hotspots on CPU 1 using a search buffer of 64 entries, reporting any entries which end up with 1000 or more hits.<br>

<br>
<a href="#Top">Up</a>
<a name="rpset"><h3>rpset</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  rp[set] {&lt;condition>}[,&lt;action>]]</font><br>
<br>
Sets a new registerpoint which will be triggered when &lt;condition> is met. The condition must be specified between curly braces to prevent the condition from being evaluated as an assignment.<br>
<br>
The optional &lt;action> parameter provides a command that is executed whenever the registerpoint is hit. Note that you may need to embed the action within braces { } in order to prevent commas and semicolons from being interpreted as applying to the rpset command itself. Each registerpoint that is set is assigned an index which can be used in other registerpoint commands to reference this registerpoint.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rp {PC==0150}</font><br>
Set a registerpoint that will halt execution whenever the PC register equals 0x150.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  temp0=0; rp {PC==0150},{temp0++; g}</font><br>
Set a registerpoint that will increment the variable temp0 whenever the PC register equals 0x0150.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rp {temp0==5}</font><br>
Set a registerpoint that will halt execution whenever the temp0 variable equals 5.<br>

<br>
<a href="#Top">Up</a>
<a name="rpclear"><h3>rpclear</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  rpclear [&lt;rpnum>]</font><br>
<br>
The rpclear command clears a registerpoint. If &lt;rpnum> is specified, only the requested registerpoint is cleared, otherwise all registerpoints are cleared.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpclear 3</font><br>
Clear registerpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpclear</font><br>
Clear all registerpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="rpdisable"><h3>rpdisable</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  rpdisable [&lt;rpnum>]</font><br>
<br>
The rpdisable command disables a registerpoint. If &lt;rpnum> is specified, only the requested registerpoint is disabled, otherwise all registerpoints are disabled. Note that disabling a registerpoint does not delete it, it just temporarily marks the registerpoint as inactive.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpdisable 3</font><br>
Disable registerpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpdisable</font><br>
Disable all registerpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="rpenable"><h3>rpenable</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  rpenable [&lt;rpnum>]</font><br>
<br>
The rpenable command enables a registerpoint. If &lt;rpnum> is specified, only the requested registerpoint is enabled, otherwise all registerpoints are enabled.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpenable 3</font><br>
Enable registerpoint index 3.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  rpenable</font><br>
Enable all registerpoints.<br>

<br>
<a href="#Top">Up</a>
<a name="rplist"><h3>rplist</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  rplist</font><br>
<br>
The rplist command lists all the current registerpoints, along with their index and any actions attached to them.<br>

<br>
<a href="#Top">Up</a>
<a name="map"><h3>map</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  map[{d|i}] &lt;address></font><br>
<br>
The map/mapd/mapi commands map a logical address in memory to the correct physical address, as well as specifying the bank. 'map' will map program space memory, while 'mapd' will map data space memory and 'mapi' will map I/O space memory.<br>
<br>
Example:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  map 152d0</font><br>
Gives physical address and bank for logical address 152d0 in program memory<br>

<br>
<a href="#Top">Up</a>
<a name="memdump"><h3>memdump</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  memdump [&lt;filename>]</font><br>
<br>
Dumps the current memory map to &lt;filename>. If &lt;filename> is omitted, then dumps to memdump.log<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  memdump mylog.log</font><br>
Dumps memory to mylog.log.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  memdump</font><br>
Dumps memory to memdump.log.<br>

<br>
<a href="#Top">Up</a>
<a name="comlist"><h3>comlist</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  comlist</font><br>
<br>
Prints the currently available comment file in human readable form in debugger output window.<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  comlist</font><br>
Shows currently available comments.<br>

<br>
<a href="#Top">Up</a>
<a name="comadd"><h3>comadd</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  comadd[//] &lt;address>,&lt;comment></font><br>
<br>
Adds a string &lt;comment> to the disassembled code at &lt;address>. The shortcut for this command is simply '//'<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  comadd 0, hello world.</font><br>
Adds the comment 'hello world.' to the code at address 0x0<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  // 10, undocumented opcode!</font><br>
Adds the comment 'undocumented opcode!' to the code at address 0x10<br>

<br>
<a href="#Top">Up</a>
<a name="commit"><h3>commit</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  commit[/*] &lt;address>,&lt;comment></font><br>
<br>
Adds a string &lt;comment> to the disassembled code at &lt;address> then saves to file. Basically same as comadd + comsave via a single line.<br>
The shortcut for this command is simply '/*'<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  commit 0, hello world.</font><br>
Adds the comment 'hello world.' to the code at address 0x0<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  /* 10, undocumented opcode!</font><br>
Adds the comment 'undocumented opcode!' to the code at address 0x10<br>

<br>
<a href="#Top">Up</a>
<a name="comsave"><h3>comsave</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  comsave</font><br>
<br>
Saves the working comments to the driver's XML comment file.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  comsave</font><br>
Saves the comments to the driver's comment file<br>
<br>

<br>
<a href="#Top">Up</a>
<a name="comdelete"><h3>comdelete</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  comdelete</font><br>
<br>
Deletes the comment at the specified memory offset. The comment which is deleted is in the currently active memory bank.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  comdelete 10</font><br>
Deletes the comment at code address 0x10 (using the current memory bank settings)<br>
<br>

<br>
<a href="#Top">Up</a>
<a name="cheatinit"><h3>cheatinit</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  cheatinit [&lt;sign>&lt;width>&lt;swap>,[&lt;address>,&lt;length>[,&lt;cpu>]]]</font><br>
<br>
The cheatinit command initializes the cheat search to the selected memory area.<br>
If no parameter is specified the cheat search is initialized to all changeable memory of the main cpu.<br>
&lt;sign> can be s(signed) or u(unsigned)<br>
&lt;width> can be b(8 bit), w(16 bit), d(32 bit) or q(64 bit)<br>
&lt;swap> append s for swapped search<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatinit ub,0x1000,0x10</font><br>
Initialize the cheat search from 0x1000 to 0x1010 of the first CPU.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatinit sw,0x2000,0x1000,1</font><br>
Initialize the cheat search with width of 2 byte in signed mode from 0x2000 to 0x3000 of the second CPU.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatinit uds,0x0000,0x1000</font><br>
Initialize the cheat search with width of 4 byte swapped from 0x0000 to 0x1000.<br>

<br>
<a href="#Top">Up</a>
<a name="cheatrange"><h3>cheatrange</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  cheatrange &lt;address>,&lt;length></font><br>
<br>
The cheatrange command adds the selected memory area to the cheat search.<br>
Before using cheatrange it is necessary to initialize the cheat search with cheatinit.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatrange 0x1000,0x10</font><br>
Add the bytes from 0x1000 to 0x1010 to the cheat search.<br>

<br>
<a href="#Top">Up</a>
<a name="cheatnext"><h3>cheatnext</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  cheatnext &lt;condition>[,&lt;comparisonvalue>]</font><br>
<br>
The cheatnext command will make comparisons with the last search matches.<br>
<br>
Possible &lt;condition>s:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  all</font><br>
No &lt;comparisonvalue> needed.<br>
Use to update the last value without changing the current matches.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  equal [eq]</font><br>
Without &lt;comparisonvalue> search for all bytes that are equal to the last search.<br>
With &lt;comparisonvalue> search for all bytes that are equal to the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  notequal [ne]</font><br>
Without &lt;comparisonvalue> search for all bytes that are not equal to the last search.<br>
With &lt;comparisonvalue> search for all bytes that are not equal to the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  decrease [de, +]</font><br>
Without &lt;comparisonvalue> search for all bytes that have decreased since the last search.<br>
With &lt;comparisonvalue> search for all bytes that have decreased by the &lt;comparisonvalue> since the last search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  increase [in, -]</font><br>
Without &lt;comparisonvalue> search for all bytes that have increased since the last search.<br>
With &lt;comparisonvalue> search for all bytes that have increased by the &lt;comparisonvalue> since the last search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  decreaseorequal [deeq]</font><br>
No &lt;comparisonvalue> needed.<br>
Search for all bytes that have decreased or have same value since the last search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  increaseorequal [ineq]</font><br>
No &lt;comparisonvalue> needed.<br>
Search for all bytes that have decreased or have same value since the last search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  smallerof [lt]</font><br>
Without &lt;comparisonvalue> this condition is invalid<br>
With &lt;comparisonvalue> search for all bytes that are smaller than the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  greaterof [gt]</font><br>
Without &lt;comparisonvalue> this condition is invalid<br>
With &lt;comparisonvalue> search for all bytes that are larger than the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  changedby [ch, ~]</font><br>
Without &lt;comparisonvalue> this condition is invalid<br>
With &lt;comparisonvalue> search for all bytes that have changed by the &lt;comparisonvalue> since the last search.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatnext increase</font><br>
Search for all bytes that have increased since the last search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatnext decrease, 1</font><br>

<br>
<a href="#Top">Up</a>
<a name="cheatnextf"><h3>cheatnextf</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  cheatnextf &lt;condition>[,&lt;comparisonvalue>]</font><br>
<br>
The cheatnextf command will make comparisons with the initial search.<br>
<br>
Possible &lt;condition>s:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  all</font><br>
No &lt;comparisonvalue> needed.<br>
Use to update the last value without changing the current matches.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  equal [eq]</font><br>
Without &lt;comparisonvalue> search for all bytes that are equal to the initial search.<br>
With &lt;comparisonvalue> search for all bytes that are equal to the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  notequal [ne]</font><br>
Without &lt;comparisonvalue> search for all bytes that are not equal to the initial search.<br>
With &lt;comparisonvalue> search for all bytes that are not equal to the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  decrease [de, +]</font><br>
Without &lt;comparisonvalue> search for all bytes that have decreased since the initial search.<br>
With &lt;comparisonvalue> search for all bytes that have decreased by the &lt;comparisonvalue> since the initial search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  increase [in, -]</font><br>
Without &lt;comparisonvalue> search for all bytes that have increased since the initial search.<br>
With &lt;comparisonvalue> search for all bytes that have increased by the &lt;comparisonvalue> since the initial search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  decreaseorequal [deeq]</font><br>
No &lt;comparisonvalue> needed.<br>
Search for all bytes that have decreased or have same value since the initial search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  increaseorequal [ineq]</font><br>
No &lt;comparisonvalue> needed.<br>
Search for all bytes that have decreased or have same value since the initial search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  smallerof [lt]</font><br>
Without &lt;comparisonvalue> this condition is invalid.<br>
With &lt;comparisonvalue> search for all bytes that are smaller than the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  greaterof [gt]</font><br>
Without &lt;comparisonvalue> this condition is invalid.<br>
With &lt;comparisonvalue> search for all bytes that are larger than the &lt;comparisonvalue>.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  changedby [ch, ~]</font><br>
Without &lt;comparisonvalue> this condition is invalid<br>
With &lt;comparisonvalue> search for all bytes that have changed by the &lt;comparisonvalue> since the initial search.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatnextf increase</font><br>
Search for all bytes that have increased since the initial search.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatnextf decrease, 1</font><br>

<br>
<a href="#Top">Up</a>
<a name="cheatlist"><h3>cheatlist</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  cheatlist [&lt;filename>]</font><br>
<br>
Without &lt;filename> show the list of matches in the debug console.<br>
With &lt;filename> save the list of matches in basic xml format to &lt;filename>.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatlist</font><br>
Show the current matches in the debug console.<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatlist cheat.txt</font><br>
Save the current matches to cheat.txt.<br>

<br>
<a href="#Top">Up</a>
<a name="cheatundo"><h3>cheatundo</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  cheatundo</font><br>
<br>
Undo the results of the last search.<br>
The undo command has no effect on the last value.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  cheatundo</font><br>
Undo the last search (state only).<br>

<br>
<a href="#Top">Up</a>
<a name="images"><h3>images</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  images</font><br>
<br>
Used to display list of available image devices.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  images</font><br>
Show list of devices and mounted files for current driver.<br>

<br>
<a href="#Top">Up</a>
<a name="mount"><h3>mount</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  mount &lt;device>,&lt;filename></font><br>
<br>
Mount &lt;filename> to image &lt;device>.<br>
&lt;filename> can be softlist item or full path to file.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  mount cart,aladdin</font><br>
Mounts softlist item alladin on cart device.<br>

<br>
<a href="#Top">Up</a>
<a name="unmount"><h3>unmount</h3></a>

&emsp;<font face="courier new" color=#000080 size=2>  unmount &lt;device></font><br>
<br>
Unmounts file from image &lt;device>.<br>
<br>
Examples:<br>
<br>
&emsp;<font face="courier new" color=#000080 size=2>  unmount cart</font><br>
Unmounts any file mounted on device named cart.<br>
</body>
</html>